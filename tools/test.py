# Copyright (c) 2026 Signer — MIT License

"""Comprehensive test suite for all crypto modules.

Tests Ed25519, X25519, ML-DSA-65, ML-KEM-768, SLH-DSA-SHAKE-128s,
Hybrid DSA (Ed25519 + ML-DSA-65), Hybrid KEM (X25519 + ML-KEM-768),
and quantum seed derivation.

Each module is tested in TWO modes:
    1. With optional C backends (pynacl / libsodium) if installed.
    2. With C backends force-disabled (pure Python fallback).

This ensures correctness regardless of whether pynacl is installed.

Includes:
    - RFC 8032 Ed25519 test vectors
    - RFC 7748 X25519 test vectors (+ 1000-iteration)
    - NIST ACVP KATs for ML-DSA-65, ML-KEM-768, SLH-DSA-SHAKE-128s
    - Round-trip and rejection tests for all algorithms
    - Hybrid DSA/KEM round-trip and tampering tests
    - Seed integration tests (get_quantum_seed, generate_quantum_keypair)

Run from the universal-quantum-seed root:
    python -m tools.test
"""

import hashlib
import importlib
import os
import random
import sys
import time
import unittest

# Ensure project root is on the import path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))


# ── Helpers ───────────────────────────────────────────────────────

def _h(hex_str):
    """Convert hex string to bytes."""
    return bytes.fromhex(hex_str.replace(" ", "").replace("\n", ""))


def _get_modules():
    """Get the actual crypto submodules (not shadowed by __init__ re-exports).

    crypto.__init__ does `from .x25519 import x25519` which shadows
    the module attribute.  Use sys.modules to get the real modules.
    """
    import crypto.ed25519
    import crypto.x25519
    import crypto.ml_kem
    import crypto.ml_dsa
    import crypto.slh_dsa
    import crypto.hybrid_dsa
    import crypto.hybrid_kem
    return (
        sys.modules["crypto.ed25519"],
        sys.modules["crypto.x25519"],
        sys.modules["crypto.ml_kem"],
        sys.modules["crypto.ml_dsa"],
        sys.modules["crypto.slh_dsa"],
        sys.modules["crypto.hybrid_dsa"],
        sys.modules["crypto.hybrid_kem"],
    )


def _force_pure_python():
    """Disable pynacl/libsodium in ALL crypto modules.

    Patches the module-level _HAS_NACL / _HAS_SODIUM flags so all code
    paths use the pure Python fallback.  Call _restore_backends() to undo.
    """
    ed, x, kem, dsa, slh, hdsa, hkem = _get_modules()

    state = {
        "ed_nacl": ed._HAS_NACL,
        "ed_sodium": ed._HAS_SODIUM,
        "x_nacl": x._HAS_NACL,
        "x_sodium": x._HAS_SODIUM,
        "kem_sodium": kem._HAS_SODIUM,
        "dsa_sodium": dsa._HAS_SODIUM,
        "slh_sodium": slh._HAS_SODIUM,
        "hdsa_sodium": hdsa._HAS_SODIUM,
        "hkem_sodium": hkem._HAS_SODIUM,
    }
    ed._HAS_NACL = False
    ed._HAS_SODIUM = False
    x._HAS_NACL = False
    x._HAS_SODIUM = False
    kem._HAS_SODIUM = False
    dsa._HAS_SODIUM = False
    slh._HAS_SODIUM = False
    hdsa._HAS_SODIUM = False
    hkem._HAS_SODIUM = False
    return state


def _restore_backends(state):
    """Restore original backend flags saved by _force_pure_python()."""
    ed, x, kem, dsa, slh, hdsa, hkem = _get_modules()

    ed._HAS_NACL = state["ed_nacl"]
    ed._HAS_SODIUM = state["ed_sodium"]
    x._HAS_NACL = state["x_nacl"]
    x._HAS_SODIUM = state["x_sodium"]
    kem._HAS_SODIUM = state["kem_sodium"]
    dsa._HAS_SODIUM = state["dsa_sodium"]
    slh._HAS_SODIUM = state["slh_sodium"]
    hdsa._HAS_SODIUM = state["hdsa_sodium"]
    hkem._HAS_SODIUM = state["hkem_sodium"]


# ── NIST ACVP Test Vectors ───────────────────────────────────────

# ML-DSA-65 keygen vector (ACVP-Server ML-DSA-keyGen-FIPS204, tgId=2, tcId=26)
_ML_DSA_KEYGEN_SEED_26 = (
    "1BD67DC782B2958E189E315C040DD1F64C8AB232A6A170E1A7A52C33F10851B1"
)
_ML_DSA_KEYGEN_PK_26 = (
    "43AD6560D3BB684667A559EE6EC7C816020E5B65671F270F2353A8C912B6C26B"
    "0DB0C2CF42DC747B10AA3EBDD573B300EEA46C4200B210094F9512119A6BB837"
    "242762B2CE94C2467278500EE7B139BED906676663355B813A9AD9D3DB70F7AF"
    "2D785040BFD51208BD3D2CFB09EAF7CEDF77D1B59DA75F7728F120C11898D9EC"
    "2CB22C73EB8F9436FF60524B56EE6B413030EB7DD10774261452CD8C5ADE75D1"
    "967628078CDA77E2B1AFB83B9F07F6939D37FF54D5E10ED17FF8A3C21546A89F"
    "514576AE780DE8761C4F2EA28828C69E38C730ACAA4CC8DC7DF63BA4C1525510"
    "FAE2C8E1B01812358BC5DFC01E955294A5DFDD1CFF0519E20B8F74FE18854D8"
    "0C86051AA5CC2FC1DB078BC785BF4BAD6832B8C269156509B332038B4C3719DC"
    "49814FC6B6AD5360E945AFFF4D4AC235F56C7F7A9A872B518C1F0D48184DA0E"
    "B318F74EB84C4F324A2BD03704D2E2A59F64A8854C7AEFB2D3530E20C8AE8A4"
    "87E6CBEDA645BD86A5A83E77A6A22888ED8E43A7F4804C2DE187F1ACBA3CF55"
    "CF99412A7A59CF77A4A977724A72686FDF7FC64492A5CB75921AD014EB727EDA"
    "1DFA7BD7ACE52FE292322F0BE0B004DCE44BEAA20FF06A7691DC36405361F924"
    "0DDF2FD1A5EC422ED639505AB8E137B971D5729B11E84C040247424A51DDDBDB"
    "C43AF261D038B0CD70D5BF44252A3786A26AF3FCD4EC100E5CDDE019F17BE6A6"
    "4F820C3F622F78D4F56A984122D6FA2D438D548DD87B9095F1FF02437854E241"
    "9A0316C33EAFFA0161737E476A9E707CC40E78686D6A043DDE962B319BE2BF9F"
    "7A1EFF9EDEFD1B4CD07131494C084083BF76181E3EB1399929314473A75E199A"
    "C9D5444DB0CEC07E625EC70C6864093961950987FB1E96DCB7E001209865D66D"
    "829CD2E2B240818CACE003C9CC74DCE5151C65E59AC1EF6D495B0C717B4412C7"
    "0B50CF44F44E648788F46BAF6F8AF3361F0E4B6119EDF6374DA596453169B935"
    "E1A3B875A6C1B9FE384AF961860514E8CF291D8650D7530DB42A46790649B5D8"
    "134AAEC33A41F0AB4296AE26203291F1C2BB5276AC305269778E7F2A4BAC15B5"
    "A31A6B6B76342596D39C7FD3D1C518689372EBD20B667BE5EE2ED11BC107A760"
    "0EDA1BE7A5DC05BB9F16D2B8BB1C7D8D10050207530BFFDAAE7B11E0615726F2"
    "E99CE99D6CA6048F9D61B14F7265473EC2D02989772B3D7E212AA68D89374C6C"
    "AF7AB160C6C5E09502049C3D03738D700457F706341DDEAFC6CA739ECFB4F193"
    "EA6B385B035EEA0F7BFD61FA776AF32AED6366E6C0642D1A01759FA6BDD295F7"
    "D18CA6DA1D48563EEE403F2F8BCB6A60326C481F12F8180B2B8117ADE61C7E29"
    "F5254207C5D4657B82BE4EBA436752EC7DA0627FCED830C15F10FB8D3CD90B45"
    "05FA325B54D954C5B6301DA72B262B226EAB2E4EE88226CC606B97736260ECB6"
    "D8F74A0440AFD5D751A90873FFF00C8D3E9CA0975F303F7AC263B8FF496C6C8F"
    "D22E8EF7B587BAB50A7DAD99BD55D3B7968584F1FB21255EE22DB56AF6034F3F"
    "13E659161A57CA8C9F2E87CA96BD7100FCEF8F74A8C6A1C92E2EFF74E2F5FAE5"
    "12C09D26E0F3985D882401EFC54727BBC0F4E1110771A106898692D0C5A6997C"
    "A742846FA4D49E8ABDF123D92743E9949BEB6E46B9655EE698C23D74991C9606"
    "7DEF06EACB981AD4A7A5ED91EACF05D374C74C443F3FBAD363B2450A1A47AAF2"
    "954D36E53B06345139138D38B941298982EEA84400C4DCC38F5127951906EE3E"
    "40F75A5DFE09FCE9BB0143A5D5ADC3C402F23A75A423AB98392CA3A4D5D23D3B"
    "CD56FF22C9612A5D2C223C7079958CD05175AA74DDD21B42051CDBDC14048CB4"
    "3CB2F6535E2CA9F5B87052F633976F4795CBA69D39F2481CFB9D210C9B0E9EFD"
    "941AC875A9A6C3E839EC54F55585721DE41815DDFC05E8A58C97E2FA52984135"
    "AAB0931094FF8400CAB043C2A5E63C2942B7D36988C4ED9B73C11D913E758ADF"
    "94291A42743E4FB04C271ED5807EA03271EA6656CF967AB2595588B55F82AF2D0"
    "7ADFFCCF859ABA70B1707B722DA1FF393CC5BBCC02014C0D4500655577946DB5"
    "F95EF1E7657DC98402E5CB048DCB372C9277FDA4D8F3A30C953822474CEEDA67"
    "0D5E680029259260D91F8737CF7572651FB28A7DF46F671679BDD507696B021C"
    "2C7F4300F3098FF9460582DB58E122C585185BCD091E7ACCB608F7E0C3558627"
    "484529A662C0528D419248B6565D32ECC78F7891DB5BB1984CDE89C1AF25F092"
    "7205E734A7DFEB9AEE94F23F2FD11FB53EC768F6B8268E00E4054CD12EDE4832"
    "B07A254A4E2241854E8FF2AE1E1B248F9EB1C77581CA2A2EF2D4C9171177A1E0"
    "40F9D4AD8D0D0C6CD14FCD13B233794E51704B6890C56BCE1B8CD1C9EAE6D59A"
    "CD91EB67B3A618D65F0F94E5458271E14DC6F6530AD0EE8B2B2F0CEC14612E56"
    "3338E241602B997EC4E62C83942C7F18DAD6841B1348CAB99A78F598FE78A202"
    "05D88D826D2E163F6B628B266C187B427F253000E4EF99FEC0494A97D9B42E37"
    "EE613767D2651FB7CB2B9E99578CE2D78B9C9777C954DBD1D7BE8B568F88AB42"
    "DDFD293BE28747103B052AD81D8F6254E426802516500111ADF0A8F27AE7C55D"
    "3D5DB86278FAF58B68A26D12B2801AC28EDA87AA5D692EDA9BE08F7CC3E78517"
    "299A3FD9CE2A0A893E12D71062AE2514C465D399F165E4D2F71D1913D8B95396"
    "681486432B090F0CCE86AA84B661FF22D4A56035E821A1CE30F33AFEB6C7B8FA"
    "9CE"
)

# ML-DSA-65 sigGen vector (ACVP-Server ML-DSA-sigGen-FIPS204, tgId=3, tcId=31)
_ML_DSA_SIGGEN_SK_31 = (
    "6CD5B575E6B85BFAD904C66BFDFDCA515265C07FB8CAAAC9C58C14FA9189D491"
    "7D7ACC758C92BAE70AB72903A2D3D4F5EDEFB2697A1430C5810BEDC137EC87EF"
    "FD2F79294AA74EB707F132B29820CD58093C1148FE6B636F7F80C72E777CCCE6"
    "E67A5CFAD97341EC995C734800363A1CE491F27196D4322105FF27AC79F5EFDA"
    "60286136357410664315776252752407756314210418571648561727268700255287"
    "331236121354365001312775767584417644322504438305111081081876026500"
    "654012713480234146182725452405316353262722273863410527682651124313"
    "617146446468763236572883683851341282053215280254740235060240850324"
    "440831272573070217326674074611777265230057000463320626533826567723"
    "546684641261361172168832416838732447000175761817884001281870505407"
    "105812083630737534234530861250140743370224166472407765428621832254"
    "533851825264762141805273862831542318003602217553874083033871231474"
    "334805553540646834361857872362721013221315154377872114283633878107"
    "148570865127122771168256788832101555628657835804815235874745320114"
    "807487105725084663633033803220002386732063125810014872862486470502"
    "711416681616285435121472675503862754211810321427030205205151784308"
    "515804520800815815621271243672214035840044743678671721546435280428"
    "360607411178157452818316372232228180847276018025186046848421146613"
    "878205377117430604356813752082000437482312436831350318874685743708"
    "464351030201325646754325872871813531455235084875066570454543830315"
    "562787262525176730227526028676753881604861747536478534804518058527"
    "772888625364743737287676713036472565548446734032381158814262076873"
    "388618386078707317050720550177184732830648637817255782143057163548"
    "418323678564081226478700114455204132122608250842301411343377243435"
    "642624754480243702417402034430237738751184615413645850651437310878"
    "848363433552805188824680247181748566622318774112322735758822785036"
    "370714450476606476010614485707027667281708801162671051001030832448"
    "207347701454665270803130540515341131722457166323840303066467002516"
    "864388122301818603411120171217517454770816548534057721877862545820"
    "644757227243578212845808300336088613441656388471213663804218601803"
    "754106013385414248661742532334208533626140056135648842078201883735"
    "074336525845347054132164800037145561552756104552631133011157715447"
    "235321406074057154263833247258731718347077202106654146544828447752"
    "640468250387231743704731012778573033613185030263185552167218032655"
    "242723205406266851367253811856371232418885125236384818716284884477"
    "010142585871436513052173017334732003261886333314274132286417376656"
    "676314711082686504118838381531507880205637004247774506481027824803"
    "432615228103572113440343856084084634237410518248520551127252336606"
    "736681557544383203111717630853205656516254475022421555881170337323"
    "534030806477563736665682820467542048717825503372863768782825134682"
    "228448434164234128341762458073372872621434547631605046447337267783"
    "236163514344622370473848833703522532828266357366354338217661800012"
    "375772585805638876304750873106124683373681371476321454728058642283"
    "077630656787704536321600871220523360851484085556121243080563345556"
    "887726833701276552087240210410034001060083231627367513775415156238"
    "517581201600130362012616084521565120517266780077748318503536524248"
    "147808167770656334505577640785201013333135BAE3FEF07D33D7B9842E4FB"
    "D3F6D285AA6B47EFA4A065158F0657A04BF437A7839C426766CC9C0849273F70"
    "5D9D63DF0E7DAA9849A312878BAD7D9FE7A9881F28D7B8646917C10C4FFE8C51"
    "DACE5BF6D5130EA118FAF211990D6AF646D26672F1AB2F69F2660D5868D95E01"
    "C8122DDCDEF420EA8815D4CE0B3D6D85684078279089A3DFD7755CAA106A2C6B"
    "4FCF17D029C85A95D1DAA7AEA75FE513C1CD73E8797A12D1494CA21FC317F9F0"
    "EAF256A61708889BBD22FE29FAD2D092E781E36F62DE70A7474145E2EB968004"
    "A3A6F46243D05682B830EFD54386753758B013C3D56F6810F3020B38F53113B6"
    "F686F0A1278E51DF2984EE3A6BEF27E8F7D1939CC37EA92022ECD1408DCBDFAB"
    "FD590325F7FC52711B7500117F0098C96143EB1A2EBFED3324FCCB6BAA53DC4B"
    "AC6CC16AA4622C94EA05B9513F9E6EB29C48682F906F81272E96CE317D869687"
    "F2AD80022A92F27F5411D547DA54D315EBE877F9DD20A74FE2F3FDEEE7296554"
    "CBD7A995E4813632F1D12965A8AE65FC3B9E8A31414A02CB084271F15669D3B9"
    "7273D8D5F4B437028C0BC0CCCEC3F4A5C7B9159E377C9578992C364B59D85AE3"
    "3BA6040A92B651BCEB410B45F5CF5597685256EDE85089C10AD26E1CBD5424E8"
    "68ECC250BDE1924613636D5534EE62C21814BD47CD558489AB9431B9594A08D6"
    "EE8252CD00E252F4DAB2DBC15B946E2C30C099AA9186ECF097BD0983E788A4C1"
    "393BFAF1648C7F20FB9D663E3A5512940F0069CFDB6077BF3D68770F36546BBF"
    "94439F0C298D5D5A0766DCA829CCB33A6F528746D370C1349C39030C462E03C8"
    "F7917C7E2B2A270FF43159C786BF1FBB9C16337F3799E2FDB382A33CB296CF85"
    "C5B947AE8A8FAC49EF4A493FAD541C81BC6C91E9821D830B6654DCC87A86EEF1"
    "55DDF00FDEC305EEF1F78FB00F5085058942A230CBACE95388F879729CE08D7F"
    "8B8BAE1E255D9B987CEAA10DD72D0EDF01832875A50FA34326EE0FE91314212A"
    "682451CDC1F4FE029D051E26678C1259E022A34DBA1606A445FDB38CCA2E3BA5"
    "66ADF56CE927D66A662DC5C27CB4152BC3E7182B36EF7A3E67F02A19AEA43A30"
    "88E7035FE0C92D4BFF9E75B7046BF862979DCC19C9B7E7434C4E6DE990C08FCC"
    "0F1DB9786AB53189DE247AD40F2239E378C19CF66B55E596AFBC90DE4917D3D4"
    "FD2D0900EC361F40A332DC5B05BE1F7FA7B55284736F4F7BBF9643D8C3E592FF"
    "065732C0AEE5C8F15FA998D77FEADA4F1743189C714149788B7E2CDC9C34C64C"
    "7217BAA52FE288DBEED183487B7E5D135FE56B989AC619F6A771CA8C6DA5D780"
    "CC02BE40D2DCC55E4FE4CA9171EEEA766C20AEAD36EA72F756D2E76C4BFA730F"
    "329CD1E36250BE6E79C0923779A74C8C792E98506D583E71870EE53E190333F8"
    "30E6E276C84DA25974B3C6D7BFFBF1DAB2A53655E005EFC4C29392C851F14CAA"
    "A17F3DD53CDDCBAC0280A47ABAF1F466C9A2B960A40501D100A659E7FE0B9C67"
    "75E8ED966AE3ECFE2D3C7E90EA8ACA6274BDADFE05DB229E3564E5647FBFBEAE"
    "A9962231D3808360565785B0C3B3F713DC0860A897EA43605FF11514AA26351021"
    "E3D469605F49522B6B3E5726FAECD59881B32F5D5FB609ABF5F282D715B8FD88"
    "FC87B280732142EA8FDB0FE25D33758572493A207AAD4D29D36DB979F3B34606"
    "F5BA3C70F2DDB60DD84B056864B59DDB3CC651960884BCB2D2F3490F3BF7EC98"
    "1F9F5C11D061642018F68DDFCE55BD59E22314349470EB70BE3F5CC31C6ECACC"
    "E6601F53AC990139385653345C335A54E16B91E5CCCD56A182981EBDF05C22A2"
    "E9F51C848FC306D9B78E99C21A1E094E8F4D8D5AA412109FE79DC58C002BC75D"
    "B3653111385E2D2C99C73A8B7D50233FEFF2FFB4BE26A04D85D05FD851746AFE"
    "0517C00EF3D930A66E119EE45C5DE23E6C2B050D7ECBF74C13BD0C6108AB2CE5"
    "76101EE88DD908E725A6CE1A1C090C6A8570174DC73F08B5139C04E71064A43D"
    "AF9DD2B4D1812390E97777CE6CA8F4FE547463C866D02DF77A9AA540E4AA7596"
    "A359800A835E4E2D23534BBEC0873242C14D95C2B14BD33D4B901CA4D4B12BE2"
    "CD53C7FA6367BE214A735ADF5844F7F3118D0CDF0ECED6095E365E4D18463726"
    "EA9FD9943C7A57F65B3450ABF855833E5AC1D97C735DC8B902760393986782F7"
    "B0833C139A86F0258701F9A65B07DF842A3F9C7550A91A94523B1431E6919ED0"
    "8A2C4CE0E764907B745F8273B6B003618085A34A37779FF9D971DC4138E28335"
    "D6BB9B4808C0AE2DB039259D46C418366A8D81BF1AE0194E8E88E471473BA163"
    "C9FF93AC4B0E4236CF4DE6B68D5A67BCEC87F9D9C236EAC2DCEA379BCA0721D2"
    "41835AFF9CDBF5289148155D077A92D67A5916949A972EC12378B015F4F60815"
    "AA18DEA20B89F8E342458DDA03A7211EA8F1150A486A5774FDB17B81D0F806C9"
    "B3CC4CDFECFDAA4D3FEDF6191C071FA30F4DD738198AC603C14BD8EE8E00F8B6"
    "EB52E3C52099ED2D338B841088563117FA33909D3ECC64A4DC26A09FE2A52269"
    "AC3142B1061742D7F294DC78E288A8BD6CBF342C3C8CB75D5D409CD6C7545D12"
    "E21DC2D5F4A0B232E50A2E55E1129442740521F6D380E1903FC00B8FB16D7C48"
    "FD1813A729C7B1B3D20F01F86F2C63FDE04C874800BC18697DAA19279DA9C359"
    "71D1CE6C42DAC2F488F07BE41DCE4B0140BA9C15CA6D077291C7494937DBED00"
    "28FAE8E1BD690C5992358279C671BF8CF0C230493604E0F75D6289C71C23A72E"
    "BE49866BF09072E8BF796BFF8BEC5B1426DF55E570EE4E48EE510D511706870F"
    "E3EC320F63AA1BA2F974FA9A97E3464C4352EBC8C1104114B4338904A2103ED4"
    "AB8ABC915D9397623E0B0ED842FC7B7C3DC8F890DE491CAAA7E5DA53F5A45FBF"
    "4AD4E850380FE7784EF174A9EA6F7983C3CC999559B5D8AF0467F135F4DDBF7E"
    "76CDBE8D89163DBE2402B5DAADEDAA1D8D0526DBCF7A4F68BD2D375B4E0F1214"
    "8C7FFD5C2D4BFD6A09FB47E66BD0B38CA3EDA4FC31955E46DE9B5D8E54C7660C"
    "C1DD46B16201FB44453687DD69B7B3F478CD77E5C98168229D259F84D4F02C290"
    "B01BFA372E471D7E66BEC67FB69FABAB568DB55DA1877D73749593953B2EA002B"
    "F2377CE235E18827C9C954B28DAC0B5650464EE005E906748E44382DCF9042E20"
    "DF3E80EE38D375043E457AF2FD13CF4F5C9CE98501E1AB1D97CA0EEC80D79B13"
    "D80ACB423996DB5CA315951EB2249F0F131118DCACBB762A99D1874ABBA59AC2"
    "828C1B8B9DF1043C00D267D9D5CAC1334DDDCD625F15625C8A287835867118709"
    "CF4CF7516FA1CF5F2E7A4404C5699118C52426C24B5BC45D3797B5C00605AD6C"
    "D1C302CC47451B433CF9896FCC23F89D295EB38B7D5D652A2E565D7BC2AAD801"
    "4A6FBA5A4CA06242C6B4AAC53FC3B464892DDBC6D0D8B4F55997BCE919690D23"
    "F56B7A8D552D5944A2F5385BF602122942193ABB3FA275FFF850FC565532BC83"
    "78F5059E3FAE22C4319D32DA76D99312274"
)
_ML_DSA_SIGGEN_MSG_31 = (
    "A54CB4BF79DDCE7D7C446F972A849DC3C75917E7ED52777590D49BA28A8171B1"
    "07650CC74348C2FD5AA5327FED13BBDF514ECCD477F4D5B213F8083CDB2923AF"
    "C35DABE663EE12932E8FDCC3058B6D991176CBAD"
)
_ML_DSA_SIGGEN_CTX_31 = (
    "0A8B9249C5794768EF495AF6483C80047295783A33DBB8B1"
)
_ML_DSA_SIGGEN_SIG_31 = (
    "E47D117DF51F7B54875CEA55017BE42F1DB20373EFC790331516CFFC243D8C18"
    "A542DD5EF98D3479758B1C598DC33E38D1497EA9A7AB23D79BBCEAC734F25C2C"
    "24D0DF4AD754DD85A4213D429DF2359BCBFDA28A5A3FE34017F24405F6B84684"
    "A3FE93C8C782C2EAA76864F197A3EF09A1F8D9F47BDB0343DFDC3672D6EE48D"
    "30ADF6E8F7217C9DA9C65F372706B939B755BA8BE1B5F23BC317369F710FB6CB"
    "EC0DE00F10C0E9213020551E3FB6E7F9067C1FD08440FDA6664BDD50228A642A"
    "A6237A815F2900B218193BD36BD04EF8F4DB9B1CF23FF9E685794B37C7B61B19"
    "8A393AD1DF702DA8110F3E0CA00C12121267D721F226FD5D6CD1F92A455F6568"
    "E420C1F547BEDC5306E2B71BF8CAB6C58E6024733649F03C0379C9CF20365966"
    "E3489E0A15727841D48E8C4145557A62E6A882F1DC2C0ACF0818382EE8BCF01F"
    "B70D0BF4208828619B10B3F0CEC9041A8F83F6164C28452F053B466261766AE4"
    "FA9C3B45531134BFCAC3E6F26E34EB8106F08C1CE7100B4AB57B6BC597B2DC35"
    "00DE9E7849E9C5F0BD32CAFE20D3F57D83B13A252A3E190A92710C29DBD48E86"
    "3FDFBCEAF4656E048CCA6832FC8867AE9209DFD571B3886D82D5FC19652FBA12"
    "35D48BFE1F5B1E0DB61ACB91872C81BC56266C02A98CD7DE70E57F3BF4892A74"
    "0EF3E99D24FDFDAEB653E0541479B5EAFEFF9C2FD7D5A61938D9A4AF56444D0F"
    "84C9185D7C9B23D0F96A50FFFBD491A550FCA2CCFCCE5ECE6A02CC5CB2661634"
    "FF4E08989AE7E75E6BA05B6A92D89E3ED7830C3D08B277B6494F6C2EC807D573"
    "1B973E0AECDD6C98736C226918D64374827AD3CCC6F170A76CC70B05B3BB5C06"
    "32A9BEDBA383EBB034DC8726284D9ACFF9D468350AB7B9FB5AB8CFE49D240DAC"
    "4FF2E971EE3B40AC3131055C29B35FEDAF567C3D4823E238AB3EC5602C27FC7C"
    "8BA6454AC72F713C1E10E47696EB104CB38C32B1BD15DC746ECE463245F1C754"
    "D0CC490F03CA647D6841421B879FAA1D2CD0EDEB5B811606049F83E6A54CA29F"
    "A68E987DC76E21FBB130AF53CB1E81F6B33C3F236040D544B13DABC6A6282DB3"
    "BFC8127258F8714ACE8B22D3D19C5039B2B6F380D6D0907534096924C6446A77"
    "1CCA6997DB2695B25F1469EEA7620CAC7304B272BA784C9FCAD29A5168D8EAAD"
    "603507DC0A9C77077D8D60AF7CF96AD78EAC512CDAA74630FB9A2CE9C59ECE85"
    "D92E8EC0E45B3D0E2379EA4F0A9148579745B11939E497DFA8B326FEF9AA4E63"
    "11CDB033A1E5AC84803B3FB397C4A72890CAC2717D6309771C137E60A1E07D29"
    "6840401CF55877FB2D6147BA60226AFEAC149E1E31A69BAF8CA114634680A741"
    "DF29A8A13FC3655A745D07A79DAB9FC4DAE7308175BF217A7C304F4CD8139D55"
    "0ECEB8FC18957222141F7A2E4BF3015FBF07A6D87DCABA68F24DC9792CE36226"
    "D095706AA728964140C24EDFD85FE9164075D015D566FBF2CA8464F5689E815F"
    "BDD22AB0758ED9AA5B34B40395E2A6B3097A808E9F28BDD6FACE3F87F1EFFFAD"
    "42898D8EA1B74CDDDD2D34BBD211180DD541B9501793978D66AD3AB3D7B6AAE1"
    "6E43C220A99CF41336F1956C74BE21F86778577B355D426C25D4739F84399FEA"
    "22E4F56326BAAEB08E3EE32915AE24894483AC9B252BE5544FECF11DC3E746DF"
    "5EF35B43CCD81498F9F6BEDDD62531CCC29641698F72E7AA5ECF63C239187BFF"
    "F798A8523BCD2EAD03C486C94280B5E7E322925F69EB9B867F42C1239C9D6F5B"
    "9D9F4D0F8F87DFEDBEF48E03EAC17A23F976FBEB76638FD6A68AE7E4D7DE1D9C"
    "4AC5249E204AB7D60F02ACB2710D6A993F4A65D01C653A90EFA290740F257A40"
    "CF1E95F4A5EAF60BDD90E65EA9838D89B383AD94EE5B6A966507D80CA9920291"
    "CDB286CE36F3285F79A7804EBDE1D3058E3CBCB485F4A016E1CCC6BC0BA126A1"
    "BDC80134741D26FC6BA3DF72350437E1804B1DF404566FF1C7C5587950A8833A"
    "B5CA0DFE2A639ED02CCDC7E25FCA9F1A3B3ACB66EB25AE31A6E4B126BD043B20"
    "D02A7A85756B31D0751550D18E65C67AD43B8375F895365AB87FAAFFE244EE2F"
    "909D47613BFA3D9696DCF1EFAC32427B99ECA020480BB6E207BDDC108052FCCC"
    "8C815B73296B51B3D3A1848CFC0E1F64D012740291AB93B0FF624A58E557D4B6"
    "6AA28BA874C15A33A07A1ECFF6AAD72693735D905B38AE1D945718371F8A4963"
    "36162CC26D2975933A56BCFE8D6751CF81815AB47F4F5EB7689C65ECAA40EF68"
    "58074FBF2F6EA854FD03E32EB7D47D0D1B024534EECC166890E6C26AB24F4545"
    "BF9EF7BAC3E431AEBBFB42E5F1E941AA08D2178531F1334F4C30165E1460F7E4"
    "5EC16B04EC4DDA388BCDAD47D0F1C88AE49C1E97E0E709A7CBC7E71FE9C60F01"
    "629644B803F3B4E3FE2E2EBE53FCC9BACF146FEF23D71FC89590E8B3370CD0BD"
    "F75EAB4058F300574E960AFF27121AF82D2F4262F13490F30FC5308F5DC9FDF3"
    "F88B52DE8B1F503E4B56548DED307CD93A73B666E09D24B04A1DC24B8EB7287C"
    "3DFC23E19406E727D196B7DC053A7FBBB14D073E922F45F2311ACB6D9E4D1ACB"
    "3DA2186A41BAAA0940845047E91B9E31468A1AD549C0576913DFE834DFEA891A"
    "556993A079B14C129C1B273BDF27DAD2857D906C8AE2ABCCB967F55932C3FC38"
    "0A1E1784811D0C8CADFCD621B16E24BA0E84AC5F099A5E77B0C6C191F6EEE50F"
    "66841729898C84E9DF25D985B748D8199E303E9E36829CAEF0ADE11B624E725A"
    "CC034CD7ECEACA81BDC208BEB05B785F2B35D4FBDBC62F7E48558887CB45ADD3"
    "9F18C609037EFFF392AAC7388763BBAB565EF73A608E3E862DE246168DA7089F"
    "4808E3CF4A4694711F554DF12C885EE028470F9C8A9E1943B3D10002AF631C8A"
    "AC815E046D8B73822EDDC2F3DAAAE89A479FCECD946D0DB9CEFEED3C0358E984"
    "12EE91C48A9414BC58BF1DAB4BEAB35B2F13ABDD35AB3BC3DB60A42C3483412B"
    "6865C5D7AEFEDB79B12BE4DCD70370E7EBAB739168299670A3CF4E2E9BE2EECC"
    "864F473FD7214676F416CBEA52E743F9C435B191BA27330919058F3B27796F6D"
    "4BDD9E4188E2FF134EE9972E0B47C614D2C1F5CF3326BA428EA3E15A141957235"
    "300D67389385F3BEA45454EE2332E5A1FA021DFD5ED6824D1DF0FBE94A6F4AEA"
    "BB197263875704B891F20B1AC47A1D2F598A769E754A865BAFAC8530A726FCA1"
    "E0FFF4726DF280A9549BDF7B59C032B5E70FF0F0B05A0789CE6A6039C5562637"
    "EBD8C2E6EEC26BFD4FA599287280BF26E68487E7E103EB5F9B97FA390943774D"
    "C9F73328E50947471976B26EA7875CA42A672C976C575319725DD41E205466EA9"
    "4F227FA77242C6866122F650B6ADD3C75E2CC8EA314F3874E3A311059550E6BD"
    "1BABE2F4FD4C5FF9E0930C910E8488C821F8BE09C2CE7278996D31A708F44D03"
    "D141999B30E99CCA6B91264EA257C5ED581E7A92925B5EB477E0C7BBF429B9DE"
    "20EB7FBA0A6C258CEA8B3A1C4AA7B8124C6ADF192C0EFA67084FCFBE9D26D309"
    "C52DA45218E8637355065C605E3F688A1DCCFAA7F5179FE650A8B002A5BB8625"
    "78E538F60925C87A8AB68A0780A71EB90A0E7BE9916982C827EE38364BE2E11F"
    "AA771060DA5514CFB11E175967016EA79953830960F9A59F132CAC4CBF7211FE2"
    "16E8CB4E1C4D5C2DD8190E4E8B7EDDB49AE79D67CF11E47B2243E60C2BD6F61"
    "4E5F92B625E941E8BB73719056A377D9D4C3063214B42D74ACE8502156A0562E"
    "6A011BE9427DB957654F04D25800466D6DF157157D3ED07D8F8CFC8375D742DB"
    "0B2ED0CB3383E2F7ADEC648F59A0B52F3C32673A2A164479D8B2E151535B3F4C"
    "34BA4078D5A4713580B103E1F5DA08463EE9A727B8E9240CEB96FC12699F0065"
    "D60C896BF9CA13478313413C94BF3E2FF46E78A00D6CC80A47290E0F35B0CCE7"
    "80E27FAEA8231E10AB52F2E749A381E6CB5381AE43CB564D05C953B1581A4E7D"
    "2D16BEBB3BCDDE7CFA85FDE822EA011479D110DF54044886D1668F0035FA3CC9"
    "06626505814D96DFE0DE6CB0F8EEBFAA720918270E55B6ADE2BDF155082EE437"
    "54B97F1FED36421691CF29A2E717055879AF86FE7E633EC0742E958B23B3FECF"
    "5E2BD110F73834AA3B9CD9379F0503B435DD67DE9A253616593408AF5A492C40"
    "A97025C76A006877DC5CC3E98BC4323A45C0F96786ADD841BA823FEE1A989B2E"
    "0A329954DC07542992D5B8747B424C94965833B89E795A108EC3BC04D6CEB180"
    "4F2B22ABE89157758F0AC3EC41526E9D0D19AFF285C7C33BDB105C7A1FE6F225"
    "8CB43F6A7CFCA44EC3AB654E3FD6F69269B782D517C3700F9CEA95C95DD0E17E"
    "77302871B4F212AF750655F019F85249FCAC5D0EDA33651FBC839B6CE4D43B62"
    "AA2AC33ABB9B74F95F65002E4AC8047AF5EDA3DC5463832F84B328CFDE01AD4C"
    "A0FD17C6263975D36490F3D51D93C97AD9B7AF04BB426DADA3206C67B2575EF3"
    "18CCE00D89B51654FAD2463CED2F73C3DBA5BD11CA84068ED37181982765DCF2"
    "5C7A3E674859C28601E0A0C10AFA98BB1CAB2C6834694AED72F276054CEDCE16"
    "F313D0571218D472912071D5B8BAA723D4C5A65A1A2B2C0FA2F385B66868993A"
    "1C11C22323B4F698F949EB4D39DC4FB0627282C496A82891757A2C3C7D9EEF1F"
    "300000000000009121D202831"
)

# SLH-DSA-SHAKE-128s keygen vectors
_SLH_DSA_KEYGEN_VECTORS = [
    {
        "tcId": 11,
        "skSeed": "C151951F3811029239B74ADD24C506AF",
        "skPrf":  "DD30363E156E6FE936EC6ED0231FEB5C",
        "pkSeed": "529FFE86200D1F32C2B60D0CD909F190",
        "sk": ("C151951F3811029239B74ADD24C506AF"
               "DD30363E156E6FE936EC6ED0231FEB5C"
               "529FFE86200D1F32C2B60D0CD909F190"
               "0761F9B727AFA724B47223016BB5B2BA"),
        "pk": ("529FFE86200D1F32C2B60D0CD909F190"
               "0761F9B727AFA724B47223016BB5B2BA"),
    },
    {
        "tcId": 12,
        "skSeed": "D3ADF41FF57EED108BEF2D8733F4C2B0",
        "skPrf":  "09A00EF4596B23E1FFD5136C135A713A",
        "pkSeed": "B64302C8D20FB89AA2414307D44E1F9C",
        "sk": ("D3ADF41FF57EED108BEF2D8733F4C2B0"
               "09A00EF4596B23E1FFD5136C135A713A"
               "B64302C8D20FB89AA2414307D44E1F9C"
               "6EFA39EBBA94B0633C900644B81DE2B9"),
        "pk": ("B64302C8D20FB89AA2414307D44E1F9C"
               "6EFA39EBBA94B0633C900644B81DE2B9"),
    },
]

# SLH-DSA sigGen vector file for tcId 214
_SLH_DSA_SIGGEN_SIG_214_FILE = os.path.join(
    os.path.dirname(__file__), "vectors", "slh_dsa_siggen_214_sig.hex"
)
_SLH_DSA_SIGGEN_SK_214 = (
    "8BE78EF32C6EEB19E88EA1ABFD1A518C"
    "1C3B7F755CEBB3BFFBFC95B45D6A4685"
    "2D28F61B5F890E74B86F7B18DC8FC59B"
    "7EA6F3763850C2025BCCAC79DD6F3457"
)
_SLH_DSA_SIGGEN_CTX_214 = (
    "4BBD539EF8E37E9816D1251C59C1364E"
    "D5EC02089406E4628DA1BAD4075EF341"
    "98AE483331A67A438DB799666321377B"
    "05B2B90C6DD7CA93F1844572260C4FB0"
    "37893E903C3C008EF96FE05F9AD5E6D2"
    "14E1E0570E2ACAD63F856F313573B36D"
)
_SLH_DSA_SIGGEN_MSG_214 = (
    "16333C4AF44B5CE609C83737AE0A1961B57AE6DA7A66E474D332DC99220A5730"
    "A78F69B3379C4DFABB5ABDF29E9D091C1E923B8CA45BFD80E773E642461741C7"
    "BBD6D5B72637F3F1078A3577E7CBE7B97523B163D112077D468FEB2B8E5585F0"
    "D2A5BE86577E3FCFF50D9FABD84310D29F7498CB08136C795D2C366507E9FFA7"
    "360DBBF79D862E0DEFB9763E8B64A97DF5F2158DFCBBFE8D9D5B0D858C2E896C"
    "4C2A1081C105C4B402958706A109D46BB1C29391564BD1478F7CFD623A30A277"
    "C0184860CF5B3F89846BD9CE038D0A9ABE48B52EA54A84948AE0DC008F481FDB"
    "638B94ABA493B367F139DBDBE05C276C7D8CAB5A0C060255C3EDF383C230C25F"
    "47B92B2BFA872769A3C235A79F48817E649F3152A867958FB68E32CCFC572A26"
    "E07B2362DB8B0CAFDF53C2A296B8E3F5B9F0DAEC57A3DA6B1C06B7063606BD65"
    "65CB5F823E3B6E3E8C89F583D2B2966D9469D3BABC8FF240FD619D49CA9838D4"
    "D795542C25785F8CAA977C4AE4D8CDB950819E6FDB94FBB9F885FA9DC718D608"
    "D4D95BA06BE6EE33D8AE4FB849EAC5F8FF6462A1A10DAE3335C01314AB383BF9"
    "4FC535AAD1CC1EB322407C8AC8307A0B99A6D5031226CE09842D6D899A1174553"
    "917E9C3F65F9FD46875C76F173360A34AAD261F8D751038882B0970A18628E9B"
    "093BD28D4C4B8BFC66278225E57358D9E0E10C2FB24E9F73FBD87AE1F6637E09"
    "825C64CC1FEB15A702144766C4FF610DA29D7D966C00F77E07E26861E29E10BD"
    "9E572546710B775E776830B9BC9766643A6D7017111C50A7A2E5C787399D0F32"
    "DE040E3B539B6B22B48EA2CCB8AA53DF79A20EF1C0FEB19C8288E1EC2E2BED2A"
    "34E9641066E006395F4105C2B8E33094C1F5B326C7442C3214651B69C4CA73BA"
    "515BAFE93F25C52CC8C635FD20C601ADF2A6A6A1E64E75E4D2A3363C0CDEFF85"
    "3E3698BA81234B789799653D28FED55AA12838C44FA1F0FA16311C7A9E6CC63DF"
    "35EEC0610B2C62B7AF643D7388C15EF2DD498D30CF2E42A3CB96D575EB66EEB7"
    "0ADC93EEDF32F4A0B45B723DC2DB383886B310D5836DBCC9DDA094FFCC171321"
    "A2004FC1FAE5A5ED1F119D8CF71F445F96A18CFE8790B7599D8ED4842013B152"
    "E7695D073ACEDA13B198653BC75A57B125B4127E69FB8BFF07898FD4F9568584"
    "4D64E64ED16914A920F5F91390BFE32D62CDDBA598FEB6CEB82F704F77FA09AB"
    "ABF6FAAA87BA7F015AAB7D20C9442E77D907CE0202317A470F6D08516A6E549D"
    "15C257BE36BC3431D0DDD71346C63BC180DABECC971F6E03B43167BCEB50DE31"
    "BEC3E60505AF5297D3662270342F797629F4A249A01261FCC85D6E89530898F24"
    "E0B42BF3C65B623235EDEF81B366123BABAC483432D3D0183236ABBD376F5B25"
    "F3DA695533331EE78E676DE13E41F331941FF49BAF730F4A196F36E532E099A3C"
    "F2DD3A697A64B9047F7B7421DF977791BEEADC1032A43C780F10B8ED366DF35A"
    "97BDAA5BB1F1041E0F7C5F33A904B24EE0A4C1226431FA9D38EC5B7E83C981DE"
    "AE1D2591E65736800D40422C4175646A8E3BB6B74BA277BD4E91B3E772115F52"
    "A9A1A80D6E418A975C0DC5DBEF482EECD3CD90E21B2B7F572A94D270EF928DD2"
    "1C3175706137381E1ED2E3CBF9A2512101A379FFE37B831F110945A65FA86A3FD"
    "8BF7D406A2F8F4DCC735E9E4A9161703B32185AD265919A71E09FF08404927C7"
    "12D5C5B128C5319FD4C657516F5FFB1FACAABF225DC6C351A90CDBD498C9931E"
    "9749449425B3AE6253D363F9BAB2A3E9EE97C1E367CF105779EB64C737957338"
    "B002141339D9A77E8E16F16E1E4D3D0DC4037A1BF24320AB5C8E7DCD222C8945"
    "417236F7C077FD58A3C426887A7CD5E7A896F3C0DAB4AAE6F9E48B37224B32B4"
    "AF6BDAF424E5A4C7C444C0AD3A1A8FE7B5900864E138B11C665BDD654FC19D74"
    "6160A30A549B77B10BD4F98BD11132D749DAF8CFBFA41542663F8F9CA6A09CCD"
    "D0A1CE7CE1D9B2BE5FC818F68B274BF5E88415DC8F7E163FDD94E41749D78924"
    "CB74A31D072B5B6FB7883DD5D3F2E74A46C9642FC5683283BEC5A84D496A369D"
    "9DFCE9626192BF5CA3EB44C1F1C4F575D22D8170651711B4E714AFC687FF4AFC"
    "4A3FAAD968B967D849D946E72D19A86E9C204C846670CD38D6522BD96AF935EA"
    "C261EBAA3391A61EA1F7F1325FF80702FE1ACFBDEA1D6E25D9DE7B1ED819C03B"
    "0B96EF242C96795BEE2691D4A6A7174160F3F33B343181A1960830BCFD944533"
    "CC97D9674977F6E145F3FF7BBF043E1A8B68A31D5D9CC2E50E289C1387CF5FDD"
    "9250D8D4B1A2BA040140C7F7169FDA322BC87C4D61D794A56C9B1A038C08321D"
    "FB060B893659D307B614F4E2323F70182C282BB9DD4AE39DEA0F2E94AA6028F6"
    "230A3686B7F65A4772598845757EA49B2FB463A50E5518219CB38F80A155514E6"
    "A6A50E6CA9FDC9FCD2A1EE56C7051699FCFF9FBAE836083E0F12684961761914"
    "EF4C5D6D8446B19B012286EE8F912B33815A802F690332031392B35B98CA1E59"
    "8F7EE8F33998F47D2E09BE1A3A1BD1C26D011380D0A992D740960678C4DFA5BF"
    "3DC0096154993495DB51D8FCDB739A190B773B3D8A5C1A98DF3D8D6E2ECFCE06"
    "06998ED434DD3AA83E9EDCEA417215CD04344892E6AB59CB953D3E8F427334B83"
    "B1A6FF0409E4D540A21E9E327AFD61ECCCFE162870921768ACE72813144CA288"
    "204991891E29DE696D09C0721E39A08BF70D30D9CB6BCD43200D3DE84E425A72"
    "90BC7C2B7958EA0DD7E1844DE53765DADF76657EBF43349C650AD1F827A64AF1"
    "57B5B9841470025C7BF01D0008325E0205658E9933A2285A4090AB7BA555FDE4"
    "E18C8033397B305E1F9910D79D753D0086875E259B2C7DD7E8F30F54DE11E59C"
    "C7BA853542D489638B19C5B18A014D4FF5799D9AF2C5AF66C1C317C2DECB77D5"
    "4AAAE8EAC5228A142240EB3A834FAB00B5DE2055F73037A0A54A67DCF8ABA476"
    "5458F12502031E15CF84DB2A7644A12990107E7341DC2E4BCFEAEDE34859A8FD"
    "6B618F34794B1124516222158C079B932DB026A1A91FE7D38D7A7023377F87F1"
    "AA672211D7CEE9C6B2179329AFBBB6400E1552C04B53649D7357035301D34BE4"
    "8BC1D14247A9A8707061F50DAD5B3A80CD71F6736403C37BA969CB804F6A28B7"
    "254074DA3C83B20498B6D40ECF0DF74EE752BD3A8A712500AC0DD5F9BE413754"
    "70C41BA4AA11D38AAC70F499046F897F6379D186BEA97B40E51EFC100E6E759D"
    "4FE87E488D6AB8B8D96BD405C21A2FA82DE46823DE873CEF1CA91F52DABCF680"
    "76B6B33407A763CBADB01DEB8887F9F471C6CCF4EEFC43F31C85FFE1365668E7"
    "575C8DBC1E916EEAE95720228A49650C9A45A933A44DED0462C1C576924D12CD"
    "D29824ED94844A2B0A7142CBF0A6C4D1FC823E59144B8F7C4A223068BC696C2C"
    "1320D95F2B519EC89ECD8F23BA2726933A81DFFE6935EEBBE7404F234CE8E889"
    "A4FCF32749FF63DC80978F02F776CC99458D41A4F301291648234E8F3E1F602D"
    "D076AA86C07C207C36D30F824C36DF35DF8D32BD06B9004F83B3A37A7B9AAF80"
    "29DB39C6AC9C16883A586DF350ACC9EB9DCA29DD9F8A090A4D4722D7046AC4A4"
    "C6502F16226D0FF95AD2371FC34D96A68AA7D5403F65E048F16C33AC95716A71"
    "683130E7435493630A69438FD2FA6670F3B8486EDC3CD60737627AB5D00A52AE"
    "520A0A39CE9A5ED306A17D156D17BB6C1203B6F81FCC8B726B0F719237AA1487"
    "7EB0978E668884BAA0582B57AF4106B904A25FE481D15EF99860B243450F3B31"
    "F92C6673D0C00E71E848C96EC613E32D42B6A162DC0DA3D524785E64FA6CF379"
    "C6F17B827E497FA6053BF235B67361E6D5BCB03878F22364AED4BD406613ADDA"
    "7E7FE2380AB8D9F2FF1A650F7252B9E1B8B488984761F9A929764B584C6EC07A"
    "4B748860652AAB5E5507AA62AB5CEAEA2D09BF368DE94EF6E04752B6172EFAA9"
    "8D105C6D4CD6FB67EB16819668D9F07C2C528747184D8A97D1C54750929674D6"
    "9E134CABC9174CA450C774088120CC2797E54C8C0598BCC9BC2574898B4C2F6F"
    "2F02C72501986178EE8CEFD50736CD565ED29CC1F593E955484E343A903B31309"
    "C7B4F4E771AFA34A7421FEEFDF507E06004C4BC7CCBEA6E513E400BCD18BB0E6"
    "BDDDA0F172D6B139F198DDFF23A938849F1435B39AD1E668A667BE22E994E352"
    "21229918D41E1A35FFE699B2274C4CD206E951B4DED10857F575108D0CB11F8A"
    "4B054C707C3E6DF0C81385A229DBDEB6F4CAD3081F2E576D921557410FE34985"
    "88C28E0502419CDAF170E2353F9B6D4CB71F705536A84DD90A4FB118195E61AB"
    "49C43E962795D5652009B06C0861BC442E70A0708F9249C758B69AD8A6BDE4A1"
    "DDEB97FCDF9BBC578FFFE87F6FA68FA42757D6FE003E96E0C01D32E4EC656508"
    "891F129806E49C046EA0AF26730AE58A9A873D0BC66EC1F0839EE07BA02BF83F"
    "265C8A54302A2C64639C6CC22F1A7FA199D210E5A48B65147443C33248FFA0DA"
    "63DE40F2AB"
)

# ML-KEM-768 KAT vectors
_KAT_KEYGEN_SEED = bytes(range(64))
_KAT_EK_SHA256 = "0b7934c83125c788995e2ba6bd761e33046b3e40571be53e023309a29f398cc9"
_KAT_DK_SHA256 = "dac268bde6a8dd238e9887117d6b664e7a7a9350ad6b7c08a948e504809572a5"
_KAT_EK_HEAD = "298aa10d423c8dda069d02bc59e6cdf03a096b8b3da4cab9b80ca4a14907672c"
_KAT_EK_TAIL = "5e43481c3eeb397eb192505229b67a201ea893c3e2cb32da8bc342fa4dea0578"
_KAT_ENCAPS_RANDOMNESS = bytes(range(32, 64))
_KAT_SS = "dfa3d17135b0c7cad38cd14d75cf05753c4060f4fff1b4df961f2774c7aa051b"
_KAT_CT_SHA256 = "1d3fc60ee5c1d56e6d65a6e453e4d17072d97b3f4c88c4939fe44573e29b1c98"

# ML-KEM-768 ACVP vectors
_ML_KEM_KEYGEN_D_26 = "A2B4BCA315A6EA4600B4A316E09A2578AA1E8BCE919C8DF3A96C71C843F5B38B"
_ML_KEM_KEYGEN_Z_26 = "D6BF055CB7B375E3271ED131F1BA31F83FEF533A239878A71074578B891265D1"
_ML_KEM_KEYGEN_EK_26 = (
    "5219C4CC17C35A828F3E21B2AB7496805C99EE041FCA0158A3314F07D053F364"
    "C887A6825958A625965D4885C2CB355E83A3C1BBB15446F891D2D24F145632CF"
    "06A5EE1A278CD3064A79AD53193853E4CEA654448A4297CEA3C9E87561629680"
    "F588953B858074292ED31C20DDD983E805D07BB9CFADD823C7900B604286C018"
    "4738CA04E0DA8289540E329605EFAA5960AAC0FD0760006C1F1993426CC7BEA2"
    "2BCBB3CC02E099B828E82F94045DFACB1D9FB315582B20D1B41476FC43AC4680"
    "647259FE9B51371223446C82E0BBAEA132913E2B96EA11950C450F25854EE4FA"
    "4921193C8F1C66D61B8265C7072B046F0C532141D51D9919C80733C1BD3C5A6D"
    "77CCB3A1938C95C1E4E866D1D65C78297B3B32CA3C4143E6A215C609A36A1B13"
    "BAA17981D42B7FF4C715AC806DC491560032A5A2BB30E476A266C6E4A4A065D9"
    "698DB08132608136082689B1B648B49063C98324706A43876507FC690893900F8"
    "166E1D52ADCC44848D864B8BA0933B32DAA63435F11065915C5D5D879EDCC136"
    "FA8515B0260B9536C316120B4904921805521C0232DA126E2A9C5323976ABC73"
    "B5AB892E59B01A194B6446C1B73217FBBA855AC887AFA58A8F15A768EF968D77"
    "5267E050150C7A8237C1024F9421C210D97907B2A144736E3B58E01C48947B1C"
    "62655E380256491CEBE400F52493D9033A29D6C9AE80B33E8C38584B30A31A37"
    "B15E85F5E82B73157408A5399A957190CBA905F1713C9ACA53AA32923CACB826"
    "9436A56BC02932189C7139D8463D0DC540621875E9A7DFEF020E7E83696C7612"
    "BC2A7DE7148D7075C31F257766301FA5A06E00582DCE15C6FB3195AF43078D79"
    "B110B5DC0789BE3A32132737FEB247DF8D2216F272C3D5BA700C52ED7E3A2795"
    "CCFE3072CD1D1B533939AC58A065A8A9FE85441ED291D43869E25307737A5155"
    "A095C5056A204326F944A9FC8F7035C931A61033CC2DB6ECEC08AAE0045A6542"
    "080C1A7BBD699902A2ECBE3A1F9AA95FC6222C6C6AB7BF96EDB3450E029B0CE1"
    "04DBBFA0A49B8044EE1BB63B33BCFAA8A6A450194CC577D490A549B6C42D6816"
    "F444AAE8B8A4F62AFFD17664E957E2BA245A864BAB8D28E82CAB9FAC3BCD707A"
    "AC19A5EE58A3925DC7059BA1B9E7A798EC987E1924342C54E5D935A6699B6D9A"
    "A78E4738B0CEC6C57D8228C86881A14A3B57065BBE5653BD92B5BD5A9888B1B1"
    "E9B017ECA1A788CBC3A283A9F7B00D3F55B138CA26C33CD2CA3BA632A0735596"
    "162AA6C9D10968F53305D35CEC4395CA0489FF631A3EF661264A22ACB535DCC1"
    "313CD6917BFE3B5B8FC3B8016CA0DFB151623C92F95701DCC4140459B52EB796"
    "FDA60FB429651052D2C16B550FA035CC1374C87A439077713769C728B766BC75"
    "A609B70BBC14AF84A3C70519C3211ACAD58BF7C14C15F1AA86FCC1DF55580A2F"
    "9BBBC31B6B0EAAB379481CE9966F7FA6487C611BA5B3E8F8307FA35CD5248C8A"
    "B351B63ABC4BA005871A97751F01E5143302C757A65E411AF7B26F22076C7A1C"
    "F7E2B0055E80D7116CA2B3056BF8754BCFA9095D0CE99715CC4512F10125C5A5"
    "00DABB7C11F5B0408377900621BE851B7A3602576650B84191749F30AC635A9E"
    "2212400769DE8E1915F26BA198AF8E53DACB598711738DA8C583A388E027A59"
)
_ML_KEM_ENCAP_M_26 = "5BD922AF345AB90F297D0A82EA39527A648E4977AB56242E2AC0ED9A2CC66F10"
_ML_KEM_ENCAP_EK_26 = (
    "F255CE47334283B8622BE7CE76D7354E3C4FE3F6C44F6BB25C9864EE0BAEB576"
    "5950D88F438263CE8B5A7A4C0FC4C95F10C477A7521F9BB458B8AA55D2E43BDC"
    "86B72F0930EE428B4C5A9C7116310F2AA5CB03AC1603C811959EA9012D69CBCE"
    "40B37CD890999CC74FF375C66F048B240363343CB795998856D560F4C712938C"
    "79466864D20B0BE95419C9EA6A8E7203A1986D10B606691242CEF630941B1164"
    "58A41C83B7DC5B06A97C840B116F2CE9CFA87A1C1AA8C4FAC137DE8498E8749B"
    "3638404271539B247183A32E7E4413B6400E0F295788084EEA93B4A7653341005"
    "672D908C62B64B11B48414B505F3036EE56CC4DA88FEF27B2DA974C9DD38C150"
    "090B5B8A29BD7C5975A8A959549044B4DAED52A7FA68335308F40C9B768C5821"
    "F78CF068A694978964F597408D09759A19578624C64DC18EAB23082E599EC488"
    "DFE016E4BA58977E15B715C612496310219B9B4775CB51C5DF03B934F7473AA5"
    "8A57C602CF17C5993D30F52D753AC56BACA1A994742BC50435E179A262B3C8EE"
    "CE1513955C593E7508B945F6E95CC4268CBD45B2504082FB8B23D8906946A74A"
    "C2FB676BDBC39DF76B9B8450F49D283C622784565B76B96084DFC099EC2279E5"
    "BC13492561B4439E32324B0050C5FE6451974BF0D72750AC58BAC046D218AC39"
    "7F65532ACC7800246ED1C8094FC807306BF88E2816AD13B06F2898CA87C486A1"
    "24B618156A090B1058722ABAE389AB5612CA2C2766DDEF98202A6AB1097B3924"
    "04EA151788528B07544325F851B4DEAA2495138F929BBB4026042B0A8CD3CB0A"
    "7D061927A717D4877E0D9A409D6B125361C99090AFDF922A776ACADA2B6A8452"
    "2134B089D4B428020C83061A87816C6A59263E636B5B2ECBCA6A64E29600948D"
    "5B0B45600B8D473A65B450B766D0251B6915898BC3C1C2C53B9679121F1F06CF"
    "B9604DE0051FF4B093939C907AB18C2988646A90481BB99F4153611C138BE34B"
    "E163B3ABAC44354A774E9CB54FB29903367C78D275467499D22E83A11CA9B844"
    "5BE9DF3CB612069222A8715A495D115B4BC2457AB731AE7EC1BD8EC9722CA980"
    "958180AC2BD67898F4A72A675106D66981B2E923C0BA40E3234655D00B25D646"
    "2591C9C9C7A53491489D57A77B2510D08B95B9C61C1784BA752F4A73023742EC"
    "B985DFB37808B16D6C283CD4A06C5A3AC401855E1DABE63F9668BF7A661946B1"
    "8230A1A5A7C19DA66ED08151E77A624F579D4E44ABE023A1CD33459FCC3F1A65"
    "89426634D062D0A75A387A0B7B8D802A66B2106E01264500915B97307C85ECF3"
    "31BCAC35E4AA243C837876D858AFA8B510C342708B38093B2CD35D1BA68DA054"
    "4794D172C6CA8850A7F847B56998D8E0B0A17144FB6F443E3679767CA91B80A6"
    "CAA8BB0E22BBAC01C0EAE1604B8A243911672B3748C7F18C531E3783D522039"
    "130057198D6F0989E99641AB718DA123710BDB67B3B75EC66BA9CF459FE06C7C"
    "4F7959DD7281FF155940B09FB14AA55CD40B963CA3312C05B36A5207C989428C"
    "16E5D288ADB18A66F74617CA39DB8AA612D706DFEC884C457AECD1AAB598195B"
    "4AC971529FB7A883492235E62112064A0F6FF5BF4F1619A0D03B96B5112009966"
    "B2DF7C2F300B6F295DF7FA2C453E1949DF6405309DF7575C7656C245EDCA9F6"
)
_ML_KEM_ENCAP_CT_26 = (
    "4EE24D9E0858B36DC755A9389F4FDBF438DB8FBFDDD2E2A41FBFE7313693E87B"
    "2BD86A2A5C95286840A2E477F4AAC12F28319D892C30FE9A120A09713369A17D"
    "5EC459C7E5DCD402F9049BF6FF0F7D07A7F18D4C1E3E0429BF6D501EEDD33E1"
    "14423A5C4692738096101EC79233F20C58A6EA7E855C4E608DA7C9EE086EEAFE"
    "296F3214BD0B9264AE18069342AB493BBEE267401FEDAE19D5F9224A11D91150"
    "5CB3200C65F17C91F88FBE25621402C939F071C48D6BC6ACD207C8C215E2FF23"
    "AB5FAD94F2CE61003C99DE15195B36ADE08864043CAEA49D4EA1D550978C4945"
    "5B06AFB4BA4F0C178D30F953D47F0258370FE8E686802085FDCB25598DE439CE"
    "EA186F848AE2E4ACF526E03755D0A89A941A08C5610C96DFB3F47C693E7E899E"
    "1DD38DFD9126F3D05751234ABB82D2BBA4D347823B97293AE2B58FD3C71D2216"
    "797DA1CA453D600C5A9A6B36CA23B9450894A894A42C40B38871F1E9E84B40A0"
    "4112CC9A4B6E7B8DE59CAE5D8389687DBB1EA078F3CC93DC5D0788A671530D9F"
    "FDE5F2CB6A558AB38E038D59ED1EF1FEE381AFB6DE0A77E1333FC5B0FE3EA2DC"
    "DB84FB33795449AC6DC322F4E5E09B2A462D3750BA426C04271903CFE9A3F022"
    "21B69E474F24B7DB608492C01AAC3F2FA472A2469B6A8A949A67C567D139D6F4"
    "0B00DF1AAC1E6456FFAA646E0DEBD79907905F28076F78ECB3DD1A6493A40F3D"
    "1F8D89C71AD15D22162264D0AA73581AF7A77EEA43B856370182348034810E60"
    "A902604B724E09EA4638AAB039982A64EF02C9C21259A381BFD3BF298EFE4285"
    "CB538F79BE01CCEE1A4A903A80132942AC6BCD4425BD197EF014E7DBEFFDFDD5"
    "AAD00DA2A5E8DE4FFF1E8E97F23F3F4BE38970AC09CB99D252CF2736059CFDE1"
    "77EA6B36EA329B9DC541C3DCE61FAC504908857184C936C1A1C4AC0C8DDE9A66"
    "B4F3AAADEAB2DBEB2F2E6422A49A6B9C223DF25A34720717253DA6DCFC0A8255"
    "53A1D2884E01A97060886FC30A1AD50E52C46F6F9B87274AD6369FCE4FDF3FF6"
    "A5D62D4AC82CBCECE902E4DE4214B71A2CA547C536380DCA26F63F2BE71B01EA"
    "C68F42AD1399D390404AA5539A5995254836FE6CF59C490B13CAC01C69E50CDC"
    "0EBA1C2F9978F4223AA38DA33639ABE933B40F6E2751515EFAC9896465041D39"
    "22A4B043897083F7CC6DAF1FD87B970BB6D1D5E48B599FE6CD2AFBA5FCE17E4B"
    "D4B0217E879FAE34FC227EC132D6F7141A48D14DED57729164A1D2B0BEF89A16"
    "244EE114AB4E108648B7E80A7DD502B0DBD0C38AF1D85AF6966BFB8E54237000"
    "A3F18C48EFEB93ED62B41A9B341361D0D7AE75D63A3A34DCEE329996AB063055"
    "3F38BC0DA148419162A31D386745C818E2691411A7927E49822AAE9EA918BF49D"
    "6809290B57C1BA5EC212F135AC0B8EE945C0510CFED4DB5A84B617BA1525E996"
    "486728E1DB87B6E99CC9A7EC4399B063D3943FE4EB1933E90365A4916CA8D67D"
    "064DF7D5B8DFC51E337247CAC3CFFAEDC5523276CDCB82B130D8E1C3FB6D7D69"
)
_ML_KEM_ENCAP_K_26 = "B2425299020BCF563B8EBE0512F0479941335A75A32B8D10BFF60E5548B64672"


# ══════════════════════════════════════════════════════════════════
# Ed25519 Tests
# ══════════════════════════════════════════════════════════════════

class TestEd25519Vectors(unittest.TestCase):
    """RFC 8032 Ed25519 test vectors (Section 7.1)."""

    def setUp(self):
        from crypto.ed25519 import ed25519_keygen, ed25519_sign, ed25519_verify
        self.keygen = ed25519_keygen
        self.sign = ed25519_sign
        self.verify = ed25519_verify

    def _vectors(self):
        return [
            {
                "seed": _h("9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60"),
                "pk": _h("d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a"),
                "msg": b"",
                "sig": _h("e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b"),
            },
            {
                "seed": _h("4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb"),
                "pk": _h("3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c"),
                "msg": _h("72"),
                "sig": _h("92a009a9f0d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb69da085ac1e43e15996e458f3613d0f11d8c387b2eaeb4302aeeb00d291612bb0c00"),
            },
            {
                "seed": _h("c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7"),
                "pk": _h("fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025"),
                "msg": _h("af82"),
                "sig": _h("6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40a"),
            },
        ]

    def test_keygen(self):
        for i, v in enumerate(self._vectors()):
            sk, pk = self.keygen(v["seed"])
            self.assertEqual(pk, v["pk"], f"Vector {i+1}: pk mismatch")

    def test_sign(self):
        for i, v in enumerate(self._vectors()):
            sk, pk = self.keygen(v["seed"])
            sig = self.sign(v["msg"], sk)
            self.assertEqual(sig, v["sig"], f"Vector {i+1}: sig mismatch")

    def test_verify(self):
        for i, v in enumerate(self._vectors()):
            self.assertTrue(self.verify(v["msg"], v["sig"], v["pk"]),
                            f"Vector {i+1}: verify failed")

    def test_reject_wrong_message(self):
        for i, v in enumerate(self._vectors()):
            self.assertFalse(self.verify(b"wrong", v["sig"], v["pk"]))


class TestEd25519RoundTrip(unittest.TestCase):
    """Ed25519 random round-trip tests."""

    def setUp(self):
        from crypto.ed25519 import ed25519_keygen, ed25519_sign, ed25519_verify
        self.keygen = ed25519_keygen
        self.sign = ed25519_sign
        self.verify = ed25519_verify

    def test_random_roundtrip(self):
        for i in range(5):
            sk, pk = self.keygen(os.urandom(32))
            self.assertEqual(len(sk), 64)
            self.assertEqual(len(pk), 32)
            msg = os.urandom(100 + i * 50)
            sig = self.sign(msg, sk)
            self.assertEqual(len(sig), 64)
            self.assertTrue(self.verify(msg, sig, pk), f"Round-trip {i} failed")
            self.assertFalse(self.verify(msg + b"\x00", sig, pk))
            bad_sig = bytearray(sig)
            bad_sig[0] ^= 0x01
            self.assertFalse(self.verify(msg, bytes(bad_sig), pk))

    def test_wrong_key(self):
        sk1, pk1 = self.keygen(os.urandom(32))
        sk2, pk2 = self.keygen(os.urandom(32))
        sig = self.sign(b"test", sk1)
        self.assertFalse(self.verify(b"test", sig, pk2))


# ══════════════════════════════════════════════════════════════════
# X25519 Tests
# ══════════════════════════════════════════════════════════════════

class TestX25519Vectors(unittest.TestCase):
    """RFC 7748 X25519 test vectors (Section 6.1)."""

    def setUp(self):
        from crypto.x25519 import x25519_keygen, x25519, _clamp, _x25519_raw, _encode_u
        self.keygen = x25519_keygen
        self.x25519 = x25519
        self._clamp = _clamp
        self._x25519_raw = _x25519_raw
        self._encode_u = _encode_u

    def test_alice_bob_dh(self):
        alice_sk = _h("77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a")
        alice_pk_expected = _h("8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a")
        bob_sk = _h("5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb")
        bob_pk_expected = _h("de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f")
        shared_expected = _h("4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742")

        basepoint = (9).to_bytes(32, 'little')
        alice_clamped = self._clamp(alice_sk)
        bob_clamped = self._clamp(bob_sk)

        alice_pk = self._encode_u(self._x25519_raw(alice_clamped, basepoint))
        self.assertEqual(alice_pk, alice_pk_expected)

        bob_pk = self._encode_u(self._x25519_raw(bob_clamped, basepoint))
        self.assertEqual(bob_pk, bob_pk_expected)

        self.assertEqual(self.x25519(alice_clamped, bob_pk_expected), shared_expected)
        self.assertEqual(self.x25519(bob_clamped, alice_pk_expected), shared_expected)

    def test_keygen_roundtrip(self):
        sk_a, pk_a = self.keygen(os.urandom(32))
        sk_b, pk_b = self.keygen(os.urandom(32))
        ss_a = self.x25519(sk_a, pk_b)
        ss_b = self.x25519(sk_b, pk_a)
        self.assertEqual(ss_a, ss_b)
        self.assertEqual(len(ss_a), 32)


class TestX25519Iterated(unittest.TestCase):
    """RFC 7748 Section 5.2: 1000-iteration stress test."""

    def test_1000_iterations(self):
        from crypto.x25519 import _x25519_raw, _encode_u
        k = (9).to_bytes(32, 'little')
        u = (9).to_bytes(32, 'little')
        for _ in range(1000):
            result = _x25519_raw(k, u)
            u = k
            k = _encode_u(result)
        expected = _h("684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51")
        self.assertEqual(k, expected)


# ══════════════════════════════════════════════════════════════════
# ML-DSA-65 Tests
# ══════════════════════════════════════════════════════════════════

class TestMLDSA65(unittest.TestCase):
    """ML-DSA-65 (FIPS 204) tests including NIST ACVP KATs."""

    @classmethod
    def setUpClass(cls):
        from crypto.ml_dsa import (
            ml_keygen, ml_sign, ml_verify, _ntt, _inv_ntt,
            _PK_SIZE, _SK_SIZE, _SIG_SIZE, _Q, _N,
        )
        cls.ml_keygen = staticmethod(ml_keygen)
        cls.ml_sign = staticmethod(ml_sign)
        cls.ml_verify = staticmethod(ml_verify)
        cls._ntt = staticmethod(_ntt)
        cls._inv_ntt = staticmethod(_inv_ntt)
        cls._PK_SIZE = _PK_SIZE
        cls._SK_SIZE = _SK_SIZE
        cls._SIG_SIZE = _SIG_SIZE
        cls._Q = _Q
        cls._N = _N
        cls.seed = _h("a0b1c2d3e4f56789a0b1c2d3e4f56789a0b1c2d3e4f56789a0b1c2d3e4f56789")
        cls.sk, cls.pk = ml_keygen(cls.seed)

    def test_ntt_roundtrip(self):
        poly = [i * 37 % self._Q for i in range(self._N)]
        self.assertEqual(self._inv_ntt(self._ntt(poly)), poly)

    def test_keygen_deterministic(self):
        sk2, pk2 = self.ml_keygen(self.seed)
        self.assertEqual(self.sk, sk2)
        self.assertEqual(self.pk, pk2)

    def test_key_sizes(self):
        self.assertEqual(len(self.sk), 4032)
        self.assertEqual(len(self.pk), 1952)

    def test_sign_verify(self):
        msg = b"test message for ML-DSA-65"
        sig = self.ml_sign(msg, self.sk)
        self.assertEqual(len(sig), 3309)
        self.assertTrue(self.ml_verify(msg, sig, self.pk))

    def test_sign_deterministic(self):
        msg = b"deterministic signing test"
        sig1 = self.ml_sign(msg, self.sk, deterministic=True)
        sig2 = self.ml_sign(msg, self.sk, deterministic=True)
        self.assertEqual(sig1, sig2)

    def test_sign_empty_message(self):
        sig = self.ml_sign(b"", self.sk)
        self.assertTrue(self.ml_verify(b"", sig, self.pk))

    def test_verify_wrong_message(self):
        sig = self.ml_sign(b"original", self.sk)
        self.assertFalse(self.ml_verify(b"tampered", sig, self.pk))

    def test_verify_wrong_key(self):
        sig = self.ml_sign(b"test", self.sk)
        _, pk2 = self.ml_keygen(os.urandom(32))
        self.assertFalse(self.ml_verify(b"test", sig, pk2))

    def test_verify_corrupted_sig(self):
        sig = self.ml_sign(b"test", self.sk)
        bad = bytearray(sig)
        bad[len(sig) // 2] ^= 0xFF
        self.assertFalse(self.ml_verify(b"test", bytes(bad), self.pk))

    def test_verify_wrong_lengths(self):
        sig = self.ml_sign(b"test", self.sk)
        self.assertFalse(self.ml_verify(b"test", sig[:-1], self.pk))
        self.assertFalse(self.ml_verify(b"test", sig, self.pk[:-1]))

    def test_context_binding(self):
        msg = b"context test"
        sig = self.ml_sign(msg, self.sk, ctx=b"test-ctx")
        self.assertTrue(self.ml_verify(msg, sig, self.pk, ctx=b"test-ctx"))
        self.assertFalse(self.ml_verify(msg, sig, self.pk, ctx=b"wrong"))
        self.assertFalse(self.ml_verify(msg, sig, self.pk))

    def test_acvp_keygen_tcId26(self):
        seed = _h(_ML_DSA_KEYGEN_SEED_26)
        expected_pk = _h(_ML_DSA_KEYGEN_PK_26)
        sk, pk = self.ml_keygen(seed)
        self.assertEqual(pk, expected_pk, "pk mismatch vs ACVP tcId=26")

    def test_acvp_siggen_tcId31(self):
        sk = _h(_ML_DSA_SIGGEN_SK_31)
        msg = _h(_ML_DSA_SIGGEN_MSG_31)
        ctx = _h(_ML_DSA_SIGGEN_CTX_31)
        expected_sig = _h(_ML_DSA_SIGGEN_SIG_31)
        sig = self.ml_sign(msg, sk, ctx=ctx, deterministic=True)
        self.assertEqual(sig, expected_sig, "sig mismatch vs ACVP tcId=31")


# ══════════════════════════════════════════════════════════════════
# ML-KEM-768 Tests
# ══════════════════════════════════════════════════════════════════

class TestMLKEMKAT(unittest.TestCase):
    """ML-KEM-768 known-answer / regression tests."""

    @classmethod
    def setUpClass(cls):
        from crypto.ml_kem import ml_kem_keygen, ml_kem_encaps, ml_kem_decaps
        cls.keygen = staticmethod(ml_kem_keygen)
        cls.encaps = staticmethod(ml_kem_encaps)
        cls.decaps = staticmethod(ml_kem_decaps)
        cls.ek, cls.dk = ml_kem_keygen(_KAT_KEYGEN_SEED)

    def test_keygen_sizes(self):
        self.assertEqual(len(self.ek), 1184)
        self.assertEqual(len(self.dk), 2400)

    def test_keygen_ek_sha256(self):
        self.assertEqual(hashlib.sha256(self.ek).hexdigest(), _KAT_EK_SHA256)

    def test_keygen_dk_sha256(self):
        self.assertEqual(hashlib.sha256(self.dk).hexdigest(), _KAT_DK_SHA256)

    def test_keygen_ek_boundaries(self):
        self.assertEqual(self.ek[:32].hex(), _KAT_EK_HEAD)
        self.assertEqual(self.ek[-32:].hex(), _KAT_EK_TAIL)

    def test_encaps_deterministic(self):
        ct, ss = self.encaps(self.ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        self.assertEqual(len(ct), 1088)
        self.assertEqual(ss.hex(), _KAT_SS)
        self.assertEqual(hashlib.sha256(ct).hexdigest(), _KAT_CT_SHA256)

    def test_decaps_roundtrip(self):
        ct, ss = self.encaps(self.ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        self.assertEqual(self.decaps(self.dk, ct), ss)

    def test_implicit_rejection(self):
        ct, ss = self.encaps(self.ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        ct_bad = bytearray(ct)
        ct_bad[0] ^= 0xFF
        ss_bad = self.decaps(self.dk, bytes(ct_bad))
        self.assertNotEqual(ss, ss_bad)
        self.assertEqual(len(ss_bad), 32)

    def test_implicit_rejection_deterministic(self):
        ct, _ = self.encaps(self.ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        ct_bad = bytearray(ct)
        ct_bad[500] ^= 0x01
        ct_bad = bytes(ct_bad)
        self.assertEqual(self.decaps(self.dk, ct_bad), self.decaps(self.dk, ct_bad))

    def test_wrong_dk(self):
        ct, ss = self.encaps(self.ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        _, dk2 = self.keygen(b"\xff" * 64)
        self.assertNotEqual(self.decaps(dk2, ct), ss)


class TestMLKEMNTT(unittest.TestCase):
    """NTT algebraic property tests for ML-KEM."""

    def setUp(self):
        from crypto.ml_kem import _Q, _N, _ntt, _ntt_inv, _multiply_ntts
        self._Q = _Q
        self._N = _N
        self._ntt = _ntt
        self._ntt_inv = _ntt_inv
        self._multiply_ntts = _multiply_ntts

    def _rand_poly(self, seed_val=None):
        rng = random.Random(seed_val)
        return [rng.randint(0, self._Q - 1) for _ in range(self._N)]

    def test_ntt_roundtrip(self):
        for s in range(5):
            f = self._rand_poly(s)
            self.assertEqual(self._ntt_inv(self._ntt(f)), f)

    def test_ntt_zero(self):
        zero = [0] * self._N
        self.assertEqual(self._ntt(zero), zero)

    def test_multiply_commutative(self):
        f = self._ntt(self._rand_poly(10))
        g = self._ntt(self._rand_poly(11))
        self.assertEqual(self._multiply_ntts(f, g), self._multiply_ntts(g, f))


class TestMLKEMByteCoding(unittest.TestCase):
    """ByteEncode / ByteDecode roundtrip tests."""

    def setUp(self):
        from crypto.ml_kem import _Q, _N, _byte_encode, _byte_decode
        self._Q = _Q
        self._N = _N
        self._byte_encode = _byte_encode
        self._byte_decode = _byte_decode

    def test_roundtrip_all_d(self):
        rng = random.Random(42)
        for d in [1, 4, 10, 12]:
            m = (1 << d) if d < 12 else self._Q
            f = [rng.randint(0, m - 1) for _ in range(self._N)]
            self.assertEqual(f, self._byte_decode(self._byte_encode(f, d), d))


class TestMLKEMCompress(unittest.TestCase):
    """Compression bounded-error tests."""

    def setUp(self):
        from crypto.ml_kem import _Q, _compress, _decompress
        self._Q = _Q
        self._compress = _compress
        self._decompress = _decompress

    def test_roundtrip_bounded_error(self):
        for d in [1, 4, 10]:
            max_err = (self._Q + (1 << d)) // (1 << (d + 1))
            for x in range(self._Q):
                c = self._compress(x, d)
                dc = self._decompress(c, d)
                err = min((x - dc) % self._Q, (dc - x) % self._Q)
                self.assertLessEqual(err, max_err)


class TestMLKEMACVP(unittest.TestCase):
    """ML-KEM-768 NIST ACVP known-answer tests."""

    @classmethod
    def setUpClass(cls):
        from crypto.ml_kem import ml_kem_keygen, ml_kem_encaps, ml_kem_decaps
        cls.keygen = staticmethod(ml_kem_keygen)
        cls.encaps = staticmethod(ml_kem_encaps)
        cls.decaps = staticmethod(ml_kem_decaps)

    def test_keygen_ek_matches_acvp(self):
        seed = _h(_ML_KEM_KEYGEN_D_26) + _h(_ML_KEM_KEYGEN_Z_26)
        ek, dk = self.keygen(seed)
        self.assertEqual(ek, _h(_ML_KEM_KEYGEN_EK_26))

    def test_encaps_ct_matches_acvp(self):
        ek = _h(_ML_KEM_ENCAP_EK_26)
        m = _h(_ML_KEM_ENCAP_M_26)
        ct, ss = self.encaps(ek, randomness=m)
        self.assertEqual(ct, _h(_ML_KEM_ENCAP_CT_26))

    def test_encaps_ss_matches_acvp(self):
        ek = _h(_ML_KEM_ENCAP_EK_26)
        m = _h(_ML_KEM_ENCAP_M_26)
        ct, ss = self.encaps(ek, randomness=m)
        self.assertEqual(ss, _h(_ML_KEM_ENCAP_K_26))


class TestMLKEMInputValidation(unittest.TestCase):
    """ML-KEM input validation tests."""

    def test_keygen_wrong_seed(self):
        from crypto.ml_kem import ml_kem_keygen
        with self.assertRaises(ValueError):
            ml_kem_keygen(b"\x00" * 32)

    def test_encaps_rejects_invalid_ek(self):
        from crypto.ml_kem import ml_kem_encaps
        with self.assertRaises(ValueError):
            ml_kem_encaps(b"\xff" * 1184)


# ══════════════════════════════════════════════════════════════════
# SLH-DSA-SHAKE-128s Tests
# ══════════════════════════════════════════════════════════════════

class TestSLHDSA128s(unittest.TestCase):
    """SLH-DSA-SHAKE-128s (FIPS 205) tests including NIST ACVP KATs."""

    @classmethod
    def setUpClass(cls):
        from crypto.slh_dsa import (
            slh_keygen, slh_sign, slh_verify,
            _PK_SIZE, _SK_SIZE, _SIG_SIZE,
        )
        cls.slh_keygen = staticmethod(slh_keygen)
        cls.slh_sign = staticmethod(slh_sign)
        cls.slh_verify = staticmethod(slh_verify)
        cls._PK_SIZE = _PK_SIZE
        cls._SK_SIZE = _SK_SIZE
        cls._SIG_SIZE = _SIG_SIZE
        cls.seed = _h(
            "a0b1c2d3e4f56789a0b1c2d3e4f56789"
            "b0c1d2e3f4a56789b0c1d2e3f4a56789"
            "c0d1e2f3a4b56789c0d1e2f3a4b56789"
        )
        cls.sk, cls.pk = slh_keygen(cls.seed)

    def test_keygen_deterministic(self):
        sk2, pk2 = self.slh_keygen(self.seed)
        self.assertEqual(self.sk, sk2)
        self.assertEqual(self.pk, pk2)

    def test_key_sizes(self):
        self.assertEqual(len(self.sk), 64)
        self.assertEqual(len(self.pk), 32)

    def test_sign_verify(self):
        msg = b"test message for SLH-DSA"
        sig = self.slh_sign(msg, self.sk)
        self.assertEqual(len(sig), 7856)
        self.assertTrue(self.slh_verify(msg, sig, self.pk))

    def test_sign_deterministic(self):
        msg = b"deterministic"
        sig1 = self.slh_sign(msg, self.sk, deterministic=True)
        sig2 = self.slh_sign(msg, self.sk, deterministic=True)
        self.assertEqual(sig1, sig2)

    def test_verify_wrong_message(self):
        sig = self.slh_sign(b"original", self.sk)
        self.assertFalse(self.slh_verify(b"tampered", sig, self.pk))

    def test_verify_wrong_key(self):
        sig = self.slh_sign(b"test", self.sk)
        _, pk2 = self.slh_keygen(os.urandom(48))
        self.assertFalse(self.slh_verify(b"test", sig, pk2))

    def test_verify_corrupted_sig(self):
        sig = self.slh_sign(b"test", self.sk)
        bad = bytearray(sig)
        bad[100] ^= 0xFF
        self.assertFalse(self.slh_verify(b"test", bytes(bad), self.pk))

    def test_context_binding(self):
        msg = b"context test"
        sig = self.slh_sign(msg, self.sk, ctx=b"test-ctx")
        self.assertTrue(self.slh_verify(msg, sig, self.pk, ctx=b"test-ctx"))
        self.assertFalse(self.slh_verify(msg, sig, self.pk, ctx=b"wrong"))

    def test_acvp_keygen_tcId11(self):
        vec = _SLH_DSA_KEYGEN_VECTORS[0]
        seed = _h(vec["skSeed"] + vec["skPrf"] + vec["pkSeed"])
        sk, pk = self.slh_keygen(seed)
        self.assertEqual(sk, _h(vec["sk"]))
        self.assertEqual(pk, _h(vec["pk"]))

    def test_acvp_keygen_tcId12(self):
        vec = _SLH_DSA_KEYGEN_VECTORS[1]
        seed = _h(vec["skSeed"] + vec["skPrf"] + vec["pkSeed"])
        sk, pk = self.slh_keygen(seed)
        self.assertEqual(sk, _h(vec["sk"]))
        self.assertEqual(pk, _h(vec["pk"]))

    def test_acvp_siggen_tcId214(self):
        if not os.path.exists(_SLH_DSA_SIGGEN_SIG_214_FILE):
            self.skipTest("SLH-DSA sigGen vector file not found")
        with open(_SLH_DSA_SIGGEN_SIG_214_FILE) as f:
            expected_sig = _h(f.read().strip())
        sk = _h(_SLH_DSA_SIGGEN_SK_214)
        msg = _h(_SLH_DSA_SIGGEN_MSG_214)
        ctx = _h(_SLH_DSA_SIGGEN_CTX_214)
        sig = self.slh_sign(msg, sk, ctx=ctx, deterministic=True)
        self.assertEqual(sig, expected_sig)


# ══════════════════════════════════════════════════════════════════
# Hybrid DSA Tests
# ══════════════════════════════════════════════════════════════════

class TestHybridDSA(unittest.TestCase):
    """Hybrid Ed25519 + ML-DSA-65 tests."""

    @classmethod
    def setUpClass(cls):
        from crypto.hybrid_dsa import (
            hybrid_dsa_keygen, hybrid_dsa_sign, hybrid_dsa_verify,
            HYBRID_DSA_SK_SIZE, HYBRID_DSA_PK_SIZE, HYBRID_DSA_SIG_SIZE,
        )
        cls.keygen = staticmethod(hybrid_dsa_keygen)
        cls.sign = staticmethod(hybrid_dsa_sign)
        cls.verify = staticmethod(hybrid_dsa_verify)
        cls.SK_SIZE = HYBRID_DSA_SK_SIZE
        cls.PK_SIZE = HYBRID_DSA_PK_SIZE
        cls.SIG_SIZE = HYBRID_DSA_SIG_SIZE
        seed = hashlib.sha512(b"test-hybrid-dsa").digest()
        cls.sk, cls.pk = hybrid_dsa_keygen(seed)
        cls.seed = seed

    def test_sizes(self):
        self.assertEqual(len(self.sk), self.SK_SIZE)
        self.assertEqual(len(self.pk), self.PK_SIZE)

    def test_sign_verify(self):
        sig = self.sign(b"hello", self.sk)
        self.assertEqual(len(sig), self.SIG_SIZE)
        self.assertTrue(self.verify(b"hello", sig, self.pk))

    def test_context(self):
        sig = self.sign(b"msg", self.sk, ctx=b"backup")
        self.assertTrue(self.verify(b"msg", sig, self.pk, ctx=b"backup"))
        self.assertFalse(self.verify(b"msg", sig, self.pk, ctx=b"wrong"))

    def test_tamper_ed25519(self):
        sig = self.sign(b"msg", self.sk)
        bad = bytearray(sig)
        bad[0] ^= 0x01
        self.assertFalse(self.verify(b"msg", bytes(bad), self.pk))

    def test_tamper_ml_dsa(self):
        sig = self.sign(b"msg", self.sk)
        bad = bytearray(sig)
        bad[64] ^= 0x01
        self.assertFalse(self.verify(b"msg", bytes(bad), self.pk))

    def test_wrong_key(self):
        sig = self.sign(b"msg", self.sk)
        seed2 = hashlib.sha512(b"different-seed").digest()
        _, pk2 = self.keygen(seed2)
        self.assertFalse(self.verify(b"msg", sig, pk2))

    def test_wrong_message(self):
        sig = self.sign(b"msg", self.sk)
        self.assertFalse(self.verify(b"wrong", sig, self.pk))

    def test_bad_sizes(self):
        sig = self.sign(b"msg", self.sk)
        self.assertFalse(self.verify(b"msg", sig[:10], self.pk))
        self.assertFalse(self.verify(b"msg", sig, self.pk[:10]))

    def test_deterministic_keygen(self):
        sk2, pk2 = self.keygen(self.seed)
        self.assertEqual(self.sk, sk2)
        self.assertEqual(self.pk, pk2)


# ══════════════════════════════════════════════════════════════════
# Hybrid KEM Tests
# ══════════════════════════════════════════════════════════════════

class TestHybridKEM(unittest.TestCase):
    """Hybrid X25519 + ML-KEM-768 tests."""

    @classmethod
    def setUpClass(cls):
        from crypto.hybrid_kem import (
            hybrid_kem_keygen, hybrid_kem_encaps, hybrid_kem_decaps,
            HYBRID_KEM_EK_SIZE, HYBRID_KEM_DK_SIZE, HYBRID_KEM_CT_SIZE,
        )
        cls.keygen = staticmethod(hybrid_kem_keygen)
        cls.encaps = staticmethod(hybrid_kem_encaps)
        cls.decaps = staticmethod(hybrid_kem_decaps)
        cls.EK_SIZE = HYBRID_KEM_EK_SIZE
        cls.DK_SIZE = HYBRID_KEM_DK_SIZE
        cls.CT_SIZE = HYBRID_KEM_CT_SIZE

    def test_sizes(self):
        ek, dk = self.keygen(os.urandom(96))
        self.assertEqual(len(ek), self.EK_SIZE)
        self.assertEqual(len(dk), self.DK_SIZE)

    def test_roundtrip(self):
        ek, dk = self.keygen(os.urandom(96))
        ct, ss_enc = self.encaps(ek)
        self.assertEqual(len(ct), self.CT_SIZE)
        self.assertEqual(len(ss_enc), 32)
        ss_dec = self.decaps(dk, ct)
        self.assertEqual(ss_enc, ss_dec)

    def test_deterministic_encaps(self):
        ek, dk = self.keygen(os.urandom(96))
        r = os.urandom(64)
        ct1, ss1 = self.encaps(ek, randomness=r)
        ct2, ss2 = self.encaps(ek, randomness=r)
        self.assertEqual(ct1, ct2)
        self.assertEqual(ss1, ss2)

    def test_different_randomness(self):
        ek, dk = self.keygen(os.urandom(96))
        ct1, ss1 = self.encaps(ek, randomness=os.urandom(64))
        ct2, ss2 = self.encaps(ek, randomness=os.urandom(64))
        self.assertNotEqual(ct1, ct2)

    def test_wrong_dk(self):
        ek1, dk1 = self.keygen(os.urandom(96))
        _, dk2 = self.keygen(os.urandom(96))
        ct, ss = self.encaps(ek1)
        self.assertNotEqual(self.decaps(dk2, ct), ss)

    def test_deterministic_keygen(self):
        seed = os.urandom(96)
        ek1, dk1 = self.keygen(seed)
        ek2, dk2 = self.keygen(seed)
        self.assertEqual(ek1, ek2)
        self.assertEqual(dk1, dk2)


# ══════════════════════════════════════════════════════════════════
# Quantum Seed Derivation Tests
# ══════════════════════════════════════════════════════════════════

class TestQuantumSeed(unittest.TestCase):
    """Seed integration tests (get_quantum_seed, generate_quantum_keypair)."""

    @classmethod
    def setUpClass(cls):
        import seed
        cls.get_quantum_seed = staticmethod(seed.get_quantum_seed)
        cls.generate_quantum_keypair = staticmethod(seed.generate_quantum_keypair)
        cls.master_key = bytes(range(64))

    def test_ml_dsa_seed_size(self):
        self.assertEqual(len(self.get_quantum_seed(self.master_key, "ml-dsa-65")), 32)

    def test_slh_dsa_seed_size(self):
        self.assertEqual(len(self.get_quantum_seed(self.master_key, "slh-dsa-shake-128s")), 48)

    def test_hybrid_dsa_seed_size(self):
        self.assertEqual(len(self.get_quantum_seed(self.master_key, "hybrid-dsa-65")), 64)

    def test_hybrid_kem_seed_size(self):
        self.assertEqual(len(self.get_quantum_seed(self.master_key, "hybrid-kem-768")), 96)

    def test_deterministic(self):
        s1 = self.get_quantum_seed(self.master_key, "ml-dsa-65")
        s2 = self.get_quantum_seed(self.master_key, "ml-dsa-65")
        self.assertEqual(s1, s2)

    def test_different_algos_different_seeds(self):
        ml = self.get_quantum_seed(self.master_key, "ml-dsa-65")
        slh = self.get_quantum_seed(self.master_key, "slh-dsa-shake-128s")
        self.assertNotEqual(ml, slh[:32])

    def test_domain_independence(self):
        ml = self.get_quantum_seed(self.master_key, "ml-dsa-65")
        hybrid = self.get_quantum_seed(self.master_key, "hybrid-dsa-65")
        self.assertNotEqual(ml, hybrid[:32])

    def test_different_indexes(self):
        s0 = self.get_quantum_seed(self.master_key, "ml-dsa-65", key_index=0)
        s1 = self.get_quantum_seed(self.master_key, "ml-dsa-65", key_index=1)
        self.assertNotEqual(s0, s1)

    def test_wrong_master_key_length(self):
        with self.assertRaises(ValueError):
            self.get_quantum_seed(b"\x00" * 32, "ml-dsa-65")

    def test_unknown_algorithm(self):
        with self.assertRaises(ValueError):
            self.get_quantum_seed(self.master_key, "unknown-algo")

    def test_full_pipeline_ml_dsa(self):
        from crypto.ml_dsa import ml_sign, ml_verify
        sk, pk = self.generate_quantum_keypair(self.master_key, "ml-dsa-65")
        sig = ml_sign(b"pipeline test", sk)
        self.assertTrue(ml_verify(b"pipeline test", sig, pk))

    def test_full_pipeline_slh_dsa(self):
        from crypto.slh_dsa import slh_sign, slh_verify
        sk, pk = self.generate_quantum_keypair(self.master_key, "slh-dsa-shake-128s")
        sig = slh_sign(b"pipeline test", sk)
        self.assertTrue(slh_verify(b"pipeline test", sig, pk))

    def test_full_pipeline_hybrid_dsa(self):
        from crypto.hybrid_dsa import hybrid_dsa_sign, hybrid_dsa_verify
        sk, pk = self.generate_quantum_keypair(self.master_key, "hybrid-dsa-65")
        sig = hybrid_dsa_sign(b"pipeline test", sk)
        self.assertTrue(hybrid_dsa_verify(b"pipeline test", sig, pk))

    def test_full_pipeline_hybrid_kem(self):
        from crypto.hybrid_kem import hybrid_kem_encaps, hybrid_kem_decaps
        # generate_quantum_keypair returns (dk, ek) for KEM algorithms
        dk, ek = self.generate_quantum_keypair(self.master_key, "hybrid-kem-768")
        ct, ss_enc = hybrid_kem_encaps(ek)
        ss_dec = hybrid_kem_decaps(dk, ct)
        self.assertEqual(ss_enc, ss_dec)

    def test_word_count_enforcement(self):
        with self.assertRaises(ValueError):
            self.get_quantum_seed(self.master_key, "ml-dsa-65", _word_count=24)
        s = self.get_quantum_seed(self.master_key, "ml-dsa-65", _word_count=36)
        self.assertEqual(len(s), 32)


# ══════════════════════════════════════════════════════════════════
# Pure Python Fallback Tests
#
# These run Ed25519, X25519, ML-KEM, and hybrid operations with
# pynacl/libsodium force-disabled, ensuring correctness of the
# pure Python code paths.
# ══════════════════════════════════════════════════════════════════

class TestEd25519PurePython(unittest.TestCase):
    """Ed25519 with pynacl force-disabled (pure Python path)."""

    @classmethod
    def setUpClass(cls):
        cls._saved = _force_pure_python()
        import crypto.ed25519 as ed
        cls.ed = ed
        # Verify we're actually in pure Python mode
        assert not ed._HAS_NACL, "Failed to disable pynacl for Ed25519"

    @classmethod
    def tearDownClass(cls):
        _restore_backends(cls._saved)

    def test_rfc8032_vector1(self):
        seed = _h("9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60")
        expected_pk = _h("d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a")
        expected_sig = _h("e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b")
        sk, pk = self.ed.ed25519_keygen(seed)
        self.assertEqual(pk, expected_pk)
        sig = self.ed.ed25519_sign(b"", sk)
        self.assertEqual(sig, expected_sig)
        self.assertTrue(self.ed.ed25519_verify(b"", sig, pk))

    def test_roundtrip(self):
        sk, pk = self.ed.ed25519_keygen(os.urandom(32))
        msg = b"pure python test message"
        sig = self.ed.ed25519_sign(msg, sk)
        self.assertTrue(self.ed.ed25519_verify(msg, sig, pk))
        self.assertFalse(self.ed.ed25519_verify(b"tampered", sig, pk))

    def test_wrong_key_rejects(self):
        sk1, pk1 = self.ed.ed25519_keygen(os.urandom(32))
        _, pk2 = self.ed.ed25519_keygen(os.urandom(32))
        sig = self.ed.ed25519_sign(b"test", sk1)
        self.assertFalse(self.ed.ed25519_verify(b"test", sig, pk2))


class TestX25519PurePython(unittest.TestCase):
    """X25519 with pynacl force-disabled (pure Python path)."""

    @classmethod
    def setUpClass(cls):
        cls._saved = _force_pure_python()
        _, x_mod, *_ = _get_modules()
        cls.x = x_mod
        assert not x_mod._HAS_NACL, "Failed to disable pynacl for X25519"

    @classmethod
    def tearDownClass(cls):
        _restore_backends(cls._saved)

    def test_rfc7748_vectors(self):
        alice_sk = _h("77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a")
        bob_sk = _h("5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb")
        shared_expected = _h("4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742")

        alice_clamped = self.x._clamp(alice_sk)
        bob_clamped = self.x._clamp(bob_sk)
        basepoint = (9).to_bytes(32, 'little')

        alice_pk = self.x._encode_u(self.x._x25519_raw(alice_clamped, basepoint))
        bob_pk = self.x._encode_u(self.x._x25519_raw(bob_clamped, basepoint))

        ss_a = self.x.x25519(alice_clamped, bob_pk)
        ss_b = self.x.x25519(bob_clamped, alice_pk)
        self.assertEqual(ss_a, shared_expected)
        self.assertEqual(ss_b, shared_expected)

    def test_keygen_dh_roundtrip(self):
        sk_a, pk_a = self.x.x25519_keygen(os.urandom(32))
        sk_b, pk_b = self.x.x25519_keygen(os.urandom(32))
        self.assertEqual(self.x.x25519(sk_a, pk_b), self.x.x25519(sk_b, pk_a))

    def test_pk_from_sk(self):
        sk, pk = self.x.x25519_keygen(os.urandom(32))
        self.assertEqual(self.x.x25519_pk_from_sk(sk), pk)


class TestMLKEMPurePython(unittest.TestCase):
    """ML-KEM-768 with libsodium memory ops force-disabled."""

    @classmethod
    def setUpClass(cls):
        cls._saved = _force_pure_python()
        import crypto.ml_kem as kem
        cls.kem = kem
        assert not kem._HAS_SODIUM, "Failed to disable libsodium for ML-KEM"

    @classmethod
    def tearDownClass(cls):
        _restore_backends(cls._saved)

    def test_roundtrip(self):
        ek, dk = self.kem.ml_kem_keygen(_KAT_KEYGEN_SEED)
        ct, ss = self.kem.ml_kem_encaps(ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        self.assertEqual(self.kem.ml_kem_decaps(dk, ct), ss)

    def test_kat_ek_sha256(self):
        ek, dk = self.kem.ml_kem_keygen(_KAT_KEYGEN_SEED)
        self.assertEqual(hashlib.sha256(ek).hexdigest(), _KAT_EK_SHA256)

    def test_implicit_rejection(self):
        ek, dk = self.kem.ml_kem_keygen(_KAT_KEYGEN_SEED)
        ct, ss = self.kem.ml_kem_encaps(ek, randomness=_KAT_ENCAPS_RANDOMNESS)
        ct_bad = bytearray(ct)
        ct_bad[0] ^= 0xFF
        ss_bad = self.kem.ml_kem_decaps(dk, bytes(ct_bad))
        self.assertNotEqual(ss, ss_bad)


class TestHybridPurePython(unittest.TestCase):
    """Hybrid DSA + KEM with pynacl/libsodium force-disabled."""

    @classmethod
    def setUpClass(cls):
        cls._saved = _force_pure_python()
        ed_mod, x_mod, kem_mod, *_ = _get_modules()
        assert not ed_mod._HAS_NACL, "Failed to disable pynacl for Ed25519"
        assert not x_mod._HAS_NACL, "Failed to disable pynacl for X25519"
        assert not kem_mod._HAS_SODIUM, "Failed to disable libsodium for ML-KEM"

    @classmethod
    def tearDownClass(cls):
        _restore_backends(cls._saved)

    def test_hybrid_dsa_roundtrip(self):
        from crypto.hybrid_dsa import hybrid_dsa_keygen, hybrid_dsa_sign, hybrid_dsa_verify
        seed = hashlib.sha512(b"pure-python-hybrid-dsa").digest()
        sk, pk = hybrid_dsa_keygen(seed)
        sig = hybrid_dsa_sign(b"pure python", sk)
        self.assertTrue(hybrid_dsa_verify(b"pure python", sig, pk))
        self.assertFalse(hybrid_dsa_verify(b"tampered", sig, pk))

    def test_hybrid_kem_roundtrip(self):
        from crypto.hybrid_kem import hybrid_kem_keygen, hybrid_kem_encaps, hybrid_kem_decaps
        ek, dk = hybrid_kem_keygen(os.urandom(96))
        ct, ss_enc = hybrid_kem_encaps(ek)
        ss_dec = hybrid_kem_decaps(dk, ct)
        self.assertEqual(ss_enc, ss_dec)

    def test_hybrid_kem_wrong_dk(self):
        from crypto.hybrid_kem import hybrid_kem_keygen, hybrid_kem_encaps, hybrid_kem_decaps
        ek1, dk1 = hybrid_kem_keygen(os.urandom(96))
        _, dk2 = hybrid_kem_keygen(os.urandom(96))
        ct, ss = hybrid_kem_encaps(ek1)
        self.assertNotEqual(hybrid_kem_decaps(dk2, ct), ss)


# ══════════════════════════════════════════════════════════════════
# Cross-backend Consistency Tests
#
# When pynacl IS available, verify that the pynacl-accelerated and
# pure-Python paths produce identical results for Ed25519 and X25519.
# ══════════════════════════════════════════════════════════════════

class TestCrossBackendConsistency(unittest.TestCase):
    """Verify pynacl and pure-Python produce identical output."""

    @classmethod
    def setUpClass(cls):
        ed_mod, x_mod, *_ = _get_modules()
        cls.has_nacl = ed_mod._HAS_NACL
        cls.ed = ed_mod
        cls.x = x_mod

    def test_ed25519_keygen_consistent(self):
        if not self.has_nacl:
            self.skipTest("pynacl not installed")
        seed = os.urandom(32)

        # pynacl path
        sk_nacl, pk_nacl = self.ed.ed25519_keygen(seed)

        # Force pure Python
        saved = _force_pure_python()
        try:
            sk_py, pk_py = self.ed.ed25519_keygen(seed)
        finally:
            _restore_backends(saved)

        self.assertEqual(pk_nacl, pk_py, "Ed25519 keygen: pynacl vs pure Python pk mismatch")

    def test_ed25519_sign_consistent(self):
        if not self.has_nacl:
            self.skipTest("pynacl not installed")
        seed = os.urandom(32)
        msg = b"cross-backend consistency test"

        sk_nacl, pk_nacl = self.ed.ed25519_keygen(seed)
        sig_nacl = self.ed.ed25519_sign(msg, sk_nacl)

        saved = _force_pure_python()
        try:
            sk_py, pk_py = self.ed.ed25519_keygen(seed)
            sig_py = self.ed.ed25519_sign(msg, sk_py)
        finally:
            _restore_backends(saved)

        self.assertEqual(sig_nacl, sig_py, "Ed25519 sign: pynacl vs pure Python sig mismatch")

    def test_x25519_keygen_consistent(self):
        if not self.has_nacl:
            self.skipTest("pynacl not installed")
        seed = os.urandom(32)

        sk_nacl, pk_nacl = self.x.x25519_keygen(seed)

        saved = _force_pure_python()
        try:
            sk_py, pk_py = self.x.x25519_keygen(seed)
        finally:
            _restore_backends(saved)

        self.assertEqual(pk_nacl, pk_py, "X25519 keygen: pynacl vs pure Python pk mismatch")

    def test_x25519_dh_consistent(self):
        if not self.has_nacl:
            self.skipTest("pynacl not installed")
        seed_a = os.urandom(32)
        seed_b = os.urandom(32)

        sk_a, pk_a = self.x.x25519_keygen(seed_a)
        sk_b, pk_b = self.x.x25519_keygen(seed_b)
        ss_nacl = self.x.x25519(sk_a, pk_b)

        saved = _force_pure_python()
        try:
            sk_a2, pk_a2 = self.x.x25519_keygen(seed_a)
            sk_b2, pk_b2 = self.x.x25519_keygen(seed_b)
            ss_py = self.x.x25519(sk_a2, pk_b2)
        finally:
            _restore_backends(saved)

        self.assertEqual(ss_nacl, ss_py, "X25519 DH: pynacl vs pure Python mismatch")


# ══════════════════════════════════════════════════════════════════
# Verify-After-Sign Tests
#
# Ensure that the fault injection countermeasure (verify-after-sign)
# is active and that signing still succeeds normally.
# ══════════════════════════════════════════════════════════════════

class TestVerifyAfterSign(unittest.TestCase):
    """Verify that sign functions include verify-after-sign countermeasure."""

    def test_ed25519_sign_succeeds(self):
        """Ed25519 signing should succeed with verify-after-sign active."""
        from crypto.ed25519 import ed25519_keygen, ed25519_sign, ed25519_verify
        sk, pk = ed25519_keygen(os.urandom(32))
        sig = ed25519_sign(b"verify-after-sign test", sk)
        self.assertTrue(ed25519_verify(b"verify-after-sign test", sig, pk))

    def test_ml_dsa_sign_succeeds(self):
        """ML-DSA signing should succeed with verify-after-sign active."""
        from crypto.ml_dsa import ml_keygen, ml_sign, ml_verify
        sk, pk = ml_keygen(os.urandom(32))
        sig = ml_sign(b"verify-after-sign test", sk)
        self.assertTrue(ml_verify(b"verify-after-sign test", sig, pk))

    def test_slh_dsa_sign_succeeds(self):
        """SLH-DSA signing should succeed with verify-after-sign active."""
        from crypto.slh_dsa import slh_keygen, slh_sign, slh_verify
        sk, pk = slh_keygen(os.urandom(48))
        sig = slh_sign(b"verify-after-sign test", sk, deterministic=True)
        self.assertTrue(slh_verify(b"verify-after-sign test", sig, pk))

    def test_hybrid_dsa_sign_succeeds(self):
        """Hybrid DSA signing should succeed with verify-after-sign active."""
        from crypto.hybrid_dsa import hybrid_dsa_keygen, hybrid_dsa_sign, hybrid_dsa_verify
        seed = hashlib.sha512(b"verify-after-sign-hybrid").digest()
        sk, pk = hybrid_dsa_keygen(seed)
        sig = hybrid_dsa_sign(b"verify-after-sign test", sk)
        self.assertTrue(hybrid_dsa_verify(b"verify-after-sign test", sig, pk))


class TestVerifyAfterSignPurePython(unittest.TestCase):
    """Verify-after-sign works with ALL backends disabled (pure Python)."""

    @classmethod
    def setUpClass(cls):
        cls._saved = _force_pure_python()

    @classmethod
    def tearDownClass(cls):
        _restore_backends(cls._saved)

    def test_ed25519_pure_python(self):
        from crypto.ed25519 import ed25519_keygen, ed25519_sign, ed25519_verify
        sk, pk = ed25519_keygen(os.urandom(32))
        sig = ed25519_sign(b"pure python vas", sk)
        self.assertTrue(ed25519_verify(b"pure python vas", sig, pk))

    def test_ml_dsa_pure_python(self):
        from crypto.ml_dsa import ml_keygen, ml_sign, ml_verify
        sk, pk = ml_keygen(os.urandom(32))
        sig = ml_sign(b"pure python vas", sk)
        self.assertTrue(ml_verify(b"pure python vas", sig, pk))

    def test_hybrid_dsa_pure_python(self):
        from crypto.hybrid_dsa import hybrid_dsa_keygen, hybrid_dsa_sign, hybrid_dsa_verify
        seed = hashlib.sha512(b"vas-pure-python-hybrid").digest()
        sk, pk = hybrid_dsa_keygen(seed)
        sig = hybrid_dsa_sign(b"pure python vas", sk)
        self.assertTrue(hybrid_dsa_verify(b"pure python vas", sig, pk))


class TestSecureMemory(unittest.TestCase):
    """Verify secure memory functions exist and work in all modules."""

    def test_ed25519_has_secure_ops(self):
        import crypto.ed25519 as ed
        self.assertTrue(callable(ed._secure_zero))
        self.assertTrue(callable(ed._mlock))
        self.assertTrue(callable(ed._munlock))
        # Test _secure_zero works on bytearray
        buf = bytearray(b"\xff" * 32)
        ed._secure_zero(buf)
        self.assertEqual(buf, bytearray(32))

    def test_x25519_has_secure_ops(self):
        _, x_mod, *_ = _get_modules()
        self.assertTrue(callable(x_mod._secure_zero))
        buf = bytearray(b"\xff" * 32)
        x_mod._secure_zero(buf)
        self.assertEqual(buf, bytearray(32))

    def test_ml_dsa_has_secure_ops(self):
        *_, dsa, _, _, _ = _get_modules()
        self.assertTrue(callable(dsa._secure_zero))
        self.assertTrue(callable(dsa._mlock))
        self.assertTrue(callable(dsa._munlock))
        buf = bytearray(b"\xff" * 32)
        dsa._secure_zero(buf)
        self.assertEqual(buf, bytearray(32))

    def test_slh_dsa_has_secure_ops(self):
        *_, slh, _, _ = _get_modules()
        self.assertTrue(callable(slh._secure_zero))
        self.assertTrue(callable(slh._mlock))
        self.assertTrue(callable(slh._munlock))
        buf = bytearray(b"\xff" * 32)
        slh._secure_zero(buf)
        self.assertEqual(buf, bytearray(32))

    def test_ml_kem_has_secure_ops(self):
        _, _, kem, *_ = _get_modules()
        self.assertTrue(callable(kem._secure_zero))
        self.assertTrue(callable(kem._mlock))
        self.assertTrue(callable(kem._munlock))

    def test_hybrid_dsa_has_secure_ops(self):
        *_, hdsa, _ = _get_modules()
        self.assertTrue(callable(hdsa._secure_zero))
        self.assertTrue(callable(hdsa._mlock))
        self.assertTrue(callable(hdsa._munlock))

    def test_hybrid_kem_has_secure_ops(self):
        *_, hkem = _get_modules()
        self.assertTrue(callable(hkem._secure_zero))
        self.assertTrue(callable(hkem._mlock))
        self.assertTrue(callable(hkem._munlock))

    def test_secure_zero_skips_immutable(self):
        """_secure_zero should silently skip immutable bytes objects."""
        import crypto.ed25519 as ed
        b = b"\xff" * 32
        ed._secure_zero(b)  # should not raise
        self.assertEqual(b, b"\xff" * 32)  # unchanged (immutable)

    def test_secure_zero_empty(self):
        """_secure_zero should handle empty buffers without error."""
        import crypto.ed25519 as ed
        buf = bytearray()
        ed._secure_zero(buf)  # should not raise


# ══════════════════════════════════════════════════════════════════
# Argon2id — Pure Python vs argon2-cffi
# ══════════════════════════════════════════════════════════════════

# Reference vectors generated by argon2-cffi (v23.1.0)
_ARGON2_VECTORS = [
    {
        "name": "minimal (8 KiB, t=1, p=1)",
        "password": b"\x01" * 32,
        "salt": b"\x02" * 16,
        "time_cost": 1,
        "memory_cost": 8,
        "parallelism": 1,
        "hash_len": 32,
        "expected": "27094ba97a2f6ad140cfbb1ffb6c8f2508b68f5e32272544c77cdd7b6994faef",
    },
    {
        "name": "small (64 KiB, t=1, p=1)",
        "password": b"test password",
        "salt": b"test salt 16b!!",
        "time_cost": 1,
        "memory_cost": 64,
        "parallelism": 1,
        "hash_len": 32,
        "expected": "c31f7f052b35a82221b0722797050294057495b7af202906ebfcf995b29d6364",
    },
    {
        "name": "medium (256 KiB, t=2, p=2, 64-byte output)",
        "password": b"hello world",
        "salt": b"saltsaltsaltsalt",
        "time_cost": 2,
        "memory_cost": 256,
        "parallelism": 2,
        "hash_len": 64,
        "expected": (
            "b7ad2f0d21e55cc7b903dc88010c79c03f6bc9c8d6816e7dad884248d20d2c69"
            "2f795b8ba24bb80cdda98e4ef4a477306f0558030b5853edc9b5efbf296ca0a4"
        ),
    },
    {
        "name": "4 lanes (128 KiB, t=1, p=4)",
        "password": b"password123",
        "salt": b"signer-salt-test",
        "time_cost": 1,
        "memory_cost": 128,
        "parallelism": 4,
        "hash_len": 32,
        "expected": "836d7c75f5da9e014e232fb210d36bcc8a83aa7176685bb8217a3b9bab0f6fcd",
    },
    {
        "name": "4 lanes, 3 iterations (128 KiB, t=3, p=4)",
        "password": b"password123",
        "salt": b"signer-salt-test",
        "time_cost": 3,
        "memory_cost": 128,
        "parallelism": 4,
        "hash_len": 32,
        "expected": "7008d4089426dbeb7f5a95eb3157edfb55aed23ef249166fe3f99ce3b1ac680b",
    },
]


class TestBlake2b(unittest.TestCase):
    """Verify pure Python Blake2b against hashlib."""

    def test_empty(self):
        from crypto.argon2 import blake2b
        for out_len in (32, 64):
            expected = hashlib.blake2b(b"", digest_size=out_len).digest()
            self.assertEqual(blake2b(b"", out_len), expected)

    def test_abc(self):
        from crypto.argon2 import blake2b
        for out_len in (32, 64):
            expected = hashlib.blake2b(b"abc", digest_size=out_len).digest()
            self.assertEqual(blake2b(b"abc", out_len), expected)

    def test_long_input(self):
        from crypto.argon2 import blake2b
        data = b"The quick brown fox jumps over the lazy dog"
        for out_len in (32, 64):
            expected = hashlib.blake2b(data, digest_size=out_len).digest()
            self.assertEqual(blake2b(data, out_len), expected)

    def test_multi_block(self):
        from crypto.argon2 import blake2b
        data = b"\xff" * 256
        for out_len in (32, 64):
            expected = hashlib.blake2b(data, digest_size=out_len).digest()
            self.assertEqual(blake2b(data, out_len), expected)

    def test_exact_block_boundary(self):
        from crypto.argon2 import blake2b
        data = b"\x00" * 128  # exactly one block
        for out_len in (32, 64):
            expected = hashlib.blake2b(data, digest_size=out_len).digest()
            self.assertEqual(blake2b(data, out_len), expected)

    def test_random_1000_bytes(self):
        from crypto.argon2 import blake2b
        data = os.urandom(1000)
        for out_len in (32, 64):
            expected = hashlib.blake2b(data, digest_size=out_len).digest()
            self.assertEqual(blake2b(data, out_len), expected)


class TestArgon2idPure(unittest.TestCase):
    """Test pure Python Argon2id against reference vectors."""

    def _run(self, vec):
        from crypto.argon2 import argon2id
        result = argon2id(
            vec["password"], vec["salt"], vec["time_cost"],
            vec["memory_cost"], vec["parallelism"], vec["hash_len"],
        )
        self.assertEqual(result.hex(), vec["expected"],
                         f"Failed: {vec['name']}")

    def test_minimal(self):
        self._run(_ARGON2_VECTORS[0])

    def test_small(self):
        self._run(_ARGON2_VECTORS[1])

    def test_medium(self):
        self._run(_ARGON2_VECTORS[2])

    def test_4_lanes(self):
        self._run(_ARGON2_VECTORS[3])

    def test_4_lanes_3_iterations(self):
        self._run(_ARGON2_VECTORS[4])


class TestArgon2idCffi(unittest.TestCase):
    """Sanity-check argon2-cffi against the same vectors."""

    def setUp(self):
        try:
            from argon2.low_level import hash_secret_raw, Type
            self._hash = hash_secret_raw
            self._type = Type.ID
        except ImportError:
            self.skipTest("argon2-cffi not installed")

    def _run(self, vec):
        result = self._hash(
            secret=vec["password"], salt=vec["salt"],
            time_cost=vec["time_cost"], memory_cost=vec["memory_cost"],
            parallelism=vec["parallelism"], hash_len=vec["hash_len"],
            type=self._type,
        )
        self.assertEqual(result.hex(), vec["expected"],
                         f"Failed: {vec['name']}")

    def test_minimal(self):
        self._run(_ARGON2_VECTORS[0])

    def test_small(self):
        self._run(_ARGON2_VECTORS[1])

    def test_medium(self):
        self._run(_ARGON2_VECTORS[2])

    def test_4_lanes(self):
        self._run(_ARGON2_VECTORS[3])

    def test_4_lanes_3_iterations(self):
        self._run(_ARGON2_VECTORS[4])


class TestArgon2idCrossBackend(unittest.TestCase):
    """Verify pure Python and cffi produce identical output."""

    def setUp(self):
        try:
            from argon2.low_level import hash_secret_raw, Type
            self._cffi_hash = hash_secret_raw
            self._cffi_type = Type.ID
        except ImportError:
            self.skipTest("argon2-cffi not installed")

    def _run(self, vec):
        from crypto.argon2 import argon2id
        cffi_result = self._cffi_hash(
            secret=vec["password"], salt=vec["salt"],
            time_cost=vec["time_cost"], memory_cost=vec["memory_cost"],
            parallelism=vec["parallelism"], hash_len=vec["hash_len"],
            type=self._cffi_type,
        )
        pure_result = argon2id(
            vec["password"], vec["salt"], vec["time_cost"],
            vec["memory_cost"], vec["parallelism"], vec["hash_len"],
        )
        self.assertEqual(cffi_result, pure_result,
                         f"Backend mismatch: {vec['name']}")

    def test_minimal(self):
        self._run(_ARGON2_VECTORS[0])

    def test_small(self):
        self._run(_ARGON2_VECTORS[1])

    def test_medium(self):
        self._run(_ARGON2_VECTORS[2])

    def test_4_lanes(self):
        self._run(_ARGON2_VECTORS[3])

    def test_4_lanes_3_iterations(self):
        self._run(_ARGON2_VECTORS[4])


class TestArgon2idWrapper(unittest.TestCase):
    """Test the unified hash_secret_raw wrapper."""

    def _run(self, vec):
        from crypto.argon2 import hash_secret_raw, Type
        result = hash_secret_raw(
            secret=vec["password"], salt=vec["salt"],
            time_cost=vec["time_cost"], memory_cost=vec["memory_cost"],
            parallelism=vec["parallelism"], hash_len=vec["hash_len"],
            type=Type.ID,
        )
        self.assertEqual(result.hex(), vec["expected"],
                         f"Failed: {vec['name']}")

    def test_minimal(self):
        self._run(_ARGON2_VECTORS[0])

    def test_small(self):
        self._run(_ARGON2_VECTORS[1])

    def test_medium(self):
        self._run(_ARGON2_VECTORS[2])

    def test_4_lanes(self):
        self._run(_ARGON2_VECTORS[3])

    def test_4_lanes_3_iterations(self):
        self._run(_ARGON2_VECTORS[4])

    def test_backend_reported(self):
        from crypto.argon2 import BACKEND
        self.assertIn(BACKEND, ("cffi", "pure"))


class TestArgon2idFallback(unittest.TestCase):
    """Test hash_secret_raw with cffi disabled (forces pure Python path)."""

    def _run(self, vec):
        import crypto.argon2 as mod
        # Temporarily disable cffi to exercise the fallback path
        saved = mod._cffi_hash
        mod._cffi_hash = None
        try:
            result = mod.hash_secret_raw(
                secret=vec["password"], salt=vec["salt"],
                time_cost=vec["time_cost"], memory_cost=vec["memory_cost"],
                parallelism=vec["parallelism"], hash_len=vec["hash_len"],
                type=2,  # raw int, since we bypassed cffi Type enum
            )
            self.assertEqual(result.hex(), vec["expected"],
                             f"Fallback failed: {vec['name']}")
        finally:
            mod._cffi_hash = saved

    def test_minimal(self):
        self._run(_ARGON2_VECTORS[0])

    def test_small(self):
        self._run(_ARGON2_VECTORS[1])

    def test_medium(self):
        self._run(_ARGON2_VECTORS[2])

    def test_4_lanes(self):
        self._run(_ARGON2_VECTORS[3])

    def test_4_lanes_3_iterations(self):
        self._run(_ARGON2_VECTORS[4])

    def test_rejects_non_argon2id(self):
        import crypto.argon2 as mod
        saved = mod._cffi_hash
        mod._cffi_hash = None
        try:
            with self.assertRaises(ValueError):
                mod.hash_secret_raw(
                    secret=b"test", salt=b"saltsaltsaltsalt",
                    time_cost=1, memory_cost=8, parallelism=1,
                    hash_len=32, type=0,  # Argon2d — not supported
                )
        finally:
            mod._cffi_hash = saved


# ══════════════════════════════════════════════════════════════════
# Runner
# ══════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    # Report backend availability
    import crypto.ed25519 as _ed
    import crypto.ml_kem as _kem
    import crypto.argon2 as _argon2
    print("=" * 68)
    print("Universal Quantum Seed — Comprehensive Crypto Test Suite")
    print("=" * 68)
    print(f"  pynacl (libsodium):  {'available' if _ed._HAS_NACL else 'NOT installed (pure Python only)'}")
    print(f"  libsodium memops:    {'available' if _kem._HAS_SODIUM else 'NOT installed (fallback zeroing)'}")
    print(f"  argon2-cffi:         {'available' if _argon2._HAS_CFFI else 'NOT installed (pure Python fallback)'}")
    print("=" * 68)

    t0 = time.perf_counter()
    unittest.main(verbosity=2, exit=False)
    elapsed = time.perf_counter() - t0
    print(f"\nTotal time: {elapsed:.1f}s")
